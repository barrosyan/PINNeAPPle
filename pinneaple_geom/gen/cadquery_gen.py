"""CadQuery mesh import, parametric CAD spec, and STEP/STL conversion."""
from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Callable, Dict, Optional, Union, Tuple

import numpy as np

from pinneaple_geom.core.mesh import MeshData


# =========================================================
# Availability
# =========================================================
def cadquery_available() -> bool:
    try:
        import cadquery as cq  # noqa: F401
        return True
    except Exception:
        return False


# =========================================================
# Conversions
# =========================================================
def _tm_to_meshdata(tm) -> MeshData:
    return MeshData(
        vertices=tm.vertices.view(np.ndarray),
        faces=tm.faces.view(np.ndarray),
        normals=tm.face_normals.view(np.ndarray) if getattr(tm, "face_normals", None) is not None else None,
    )


@dataclass
class CadQueryTessellationOptions:
    """
    CadQuery tessellation controls (affect mesh fidelity and speed).

    Smaller deflection => more triangles (slower, higher fidelity)
    """
    linear_deflection: float = 0.1
    angular_deflection: float = 0.5


def cadquery_to_trimesh(
    cq_obj: Any,
    *,
    options: Optional[CadQueryTessellationOptions] = None,
):
    """
    Convert an in-memory CadQuery object (Workplane/Solid/Compound) to trimesh.Trimesh.

    MVP approach:
      - export to a temporary STL
      - load with trimesh (robust and avoids binding to CQ internals)

    Future-ready notes:
      - We keep 'options' so we can swap to direct tessellation later.
      - We return trimesh for validation/repair in future (watertight checks, etc).
    """
    if not cadquery_available():
        raise ImportError("cadquery is not installed.")

    import tempfile
    import trimesh
    import cadquery as cq  # noqa: F401

    options = options or CadQueryTessellationOptions()

    with tempfile.TemporaryDirectory() as td:
        stl_path = Path(td) / "tmp.stl"

        # Many CadQuery environments ignore advanced tessellation controls; keep simple.
        # If you later want tighter mesh:
        # cq.exporters.export(cq_obj, str(stl_path), exportType="STL", tolerance=options.linear_deflection)
        cq.exporters.export(cq_obj, str(stl_path))

        tm = trimesh.load(str(stl_path), force="mesh")
        if not isinstance(tm, trimesh.Trimesh):
            raise TypeError("CadQuery export did not produce a triangular mesh (Trimesh).")
        return tm


# =========================================================
# Parametric future: a small "CAD recipe" API layer
# =========================================================
ParamValue = Union[int, float, str, bool]
ParamSchema = Dict[str, Dict[str, Any]]
CadBuilder = Callable[[Dict[str, Any]], Any]  # returns CQ object


@dataclass
class ParametricCadSpec:
    """
    Future-ready declarative CAD spec.

    Goal:
      - User can upload a non-parametric CAD (STEP/STL) for visualization/meshing.
      - But ALSO you can expose parametric "recipes" (CadQuery builders) that
        can be re-generated by changing params (API-friendly).

    'builder_id' points to a registered CadQuery builder function.
    'params' holds the user-chosen values.
    'schema' describes min/max/type/default so a frontend can render sliders/inputs.
    """
    builder_id: str
    params: Dict[str, Any] = field(default_factory=dict)
    schema: ParamSchema = field(default_factory=dict)
    meta: Dict[str, Any] = field(default_factory=dict)

    def validate(self) -> None:
        if not self.builder_id:
            raise ValueError("ParametricCadSpec.builder_id must be non-empty")

        # Optional light schema validation (keeps it flexible)
        for k, rule in self.schema.items():
            if "type" in rule and k in self.params:
                t = rule["type"]
                v = self.params[k]
                if t in ("float", float) and not isinstance(v, (int, float)):
                    raise ValueError(f"param '{k}' must be float-like")
                if t in ("int", int) and not isinstance(v, int):
                    raise ValueError(f"param '{k}' must be int")
                if t in ("bool", bool) and not isinstance(v, bool):
                    raise ValueError(f"param '{k}' must be bool")
                if t in ("str", str) and not isinstance(v, str):
                    raise ValueError(f"param '{k}' must be str")

        # Apply min/max constraints when possible
        for k, rule in self.schema.items():
            if k not in self.params:
                continue
            v = self.params[k]
            if isinstance(v, (int, float)):
                vmin = rule.get("min", None)
                vmax = rule.get("max", None)
                if vmin is not None and v < vmin:
                    raise ValueError(f"param '{k}' must be >= {vmin}")
                if vmax is not None and v > vmax:
                    raise ValueError(f"param '{k}' must be <= {vmax}")

    def with_defaults(self) -> "ParametricCadSpec":
        if not self.schema:
            return self
        p = dict(self.params)
        for k, rule in self.schema.items():
            if k not in p and "default" in rule:
                p[k] = rule["default"]
        return ParametricCadSpec(
            builder_id=self.builder_id,
            params=p,
            schema=self.schema,
            meta=self.meta,
        )


@dataclass
class CadQueryBuildOptions:
    """
    Build controls beyond tessellation.

    - heal: attempt to clean/validate solids after import (future hook)
    - center_to_origin: convenience for simulation standardization
    - normalize_to_unit_box: convenience for ML batching (if desired)
    """
    tessellation: CadQueryTessellationOptions = field(default_factory=CadQueryTessellationOptions)
    heal: bool = False
    center_to_origin: bool = False
    normalize_to_unit_box: bool = False


@dataclass
class CadQueryRegistry:
    """
    Registry of parametric CAD builders.

    This is the missing piece for your future API:
      - upload STL/STEP -> store as a "baseline asset"
      - user selects a template (builder_id) -> params become editable
      - rebuild geometry with CadQuery -> mesh -> run new simulation
    """
    builders: Dict[str, CadBuilder] = field(default_factory=dict)
    schemas: Dict[str, ParamSchema] = field(default_factory=dict)

    def register(self, builder_id: str, builder: CadBuilder, schema: Optional[ParamSchema] = None) -> None:
        if not builder_id:
            raise ValueError("builder_id must be non-empty")
        self.builders[builder_id] = builder
        if schema is not None:
            self.schemas[builder_id] = schema

    def get_builder(self, builder_id: str) -> CadBuilder:
        if builder_id not in self.builders:
            raise KeyError(f"Unknown builder_id: {builder_id}")
        return self.builders[builder_id]

    def get_schema(self, builder_id: str) -> ParamSchema:
        return self.schemas.get(builder_id, {})

    def build(self, spec: ParametricCadSpec) -> Any:
        spec = spec.with_defaults()
        spec.validate()
        builder = self.get_builder(spec.builder_id)
        return builder(spec.params)


# =========================================================
# STEP/STL import path (non-parametric baseline)
# =========================================================
def build_mesh_from_step(
    step_path: Union[str, Path],
    *,
    options: Optional[CadQueryTessellationOptions] = None,
) -> MeshData:
    """
    Load a STEP file with CadQuery and return a triangle mesh as MeshData.

    Note:
      STEP is "non-parametric" here (just a shape). This supports uploads.
      Parametric edits are achieved via ParametricCadSpec + registry builder recipes.
    """
    if not cadquery_available():
        raise ImportError("cadquery is not installed. Install it to use STEP/CAD import.")

    import cadquery as cq

    options = options or CadQueryTessellationOptions()

    step_path = Path(step_path).expanduser().resolve()
    if not step_path.exists():
        raise FileNotFoundError(step_path)

    cq_obj = cq.importers.importStep(str(step_path))
    tm = cadquery_to_trimesh(cq_obj, options=options)
    md = _tm_to_meshdata(tm)
    if hasattr(md, "ensure_normals"):
        md.ensure_normals("face")  # type: ignore[attr-defined]
    return md


def build_mesh_from_cadquery_object(
    cq_obj: Any,
    *,
    options: Optional[CadQueryTessellationOptions] = None,
) -> MeshData:
    """
    Convert an in-memory CadQuery object (Workplane/Solid/Compound) to MeshData.
    """
    options = options or CadQueryTessellationOptions()
    tm = cadquery_to_trimesh(cq_obj, options=options)
    md = _tm_to_meshdata(tm)
    if hasattr(md, "ensure_normals"):
        md.ensure_normals("face")  # type: ignore[attr-defined]
    return md


# =========================================================
# Parametric build path (CadQuery recipe -> mesh)
# =========================================================
def build_mesh_from_parametric_spec(
    spec: ParametricCadSpec,
    registry: CadQueryRegistry,
    *,
    options: Optional[CadQueryBuildOptions] = None,
) -> MeshData:
    """
    Build a MeshData from a ParametricCadSpec using a registry builder.

    This is the "future API" hook:
      POST /cad/build {builder_id, params} -> returns mesh (or saved asset id)
    """
    if not cadquery_available():
        raise ImportError("cadquery is not installed.")

    options = options or CadQueryBuildOptions()
    cq_obj = registry.build(spec)

    md = build_mesh_from_cadquery_object(cq_obj, options=options.tessellation)

    # Optional standardization steps
    if options.center_to_origin:
        md.vertices -= md.vertices.mean(axis=0, keepdims=True)

    if options.normalize_to_unit_box and hasattr(md, "normalize_to_unit_box"):
        md.normalize_to_unit_box()  # type: ignore[attr-defined]

    return md


# =========================================================
# Example parametric builders (templates)
# =========================================================
def register_default_templates(reg: CadQueryRegistry) -> CadQueryRegistry:
    """
    Register a couple of templates to prove the concept.
    (You can add your cold-plate / channel / fin arrays here.)
    """
    if not cadquery_available():
        return reg

    import cadquery as cq

    # --- Template 1: box with cylindrical through-channel (cold-plate-ish) ---
    def cold_plate_channel(params: Dict[str, Any]) -> Any:
        Lx = float(params["Lx"])
        Ly = float(params["Ly"])
        Lz = float(params["Lz"])
        r = float(params["r"])

        wp = cq.Workplane("XY")
        block = wp.box(Lx, Ly, Lz, centered=True)
        channel = cq.Workplane("YZ").circle(r).extrude(Lx, both=True)
        solid = block.cut(channel)
        return solid

    reg.register(
        "cold_plate_channel",
        cold_plate_channel,
        schema={
            "Lx": {"type": "float", "min": 1e-4, "max": 10.0, "default": 0.20, "ui": "slider"},
            "Ly": {"type": "float", "min": 1e-4, "max": 10.0, "default": 0.12, "ui": "slider"},
            "Lz": {"type": "float", "min": 1e-4, "max": 10.0, "default": 0.012, "ui": "slider"},
            "r":  {"type": "float", "min": 1e-5, "max": 1.0,  "default": 0.004, "ui": "slider"},
        },
    )

    # --- Template 2: simple finned plate (example for param sweeps) ---
    def finned_plate(params: Dict[str, Any]) -> Any:
        Lx = float(params["Lx"])
        Ly = float(params["Ly"])
        Lz = float(params["Lz"])
        n_fins = int(params["n_fins"])
        fin_t = float(params["fin_t"])
        fin_h = float(params["fin_h"])
        gap = float(params["gap"])

        base = cq.Workplane("XY").box(Lx, Ly, Lz, centered=True)
        # fins along y, placed across x
        x0 = -0.5 * Lx + gap + 0.5 * fin_t
        pitch = fin_t + gap
        fins = []
        for i in range(n_fins):
            xi = x0 + i * pitch
            fin = (
                cq.Workplane("XY")
                .center(xi, 0.0)
                .box(fin_t, Ly, fin_h, centered=True)
                .translate((0, 0, 0.5 * (Lz + fin_h)))
            )
            fins.append(fin)
        solid = base
        for f in fins:
            solid = solid.union(f)
        return solid

    reg.register(
        "finned_plate",
        finned_plate,
        schema={
            "Lx": {"type": "float", "min": 1e-4, "max": 10.0, "default": 0.20},
            "Ly": {"type": "float", "min": 1e-4, "max": 10.0, "default": 0.12},
            "Lz": {"type": "float", "min": 1e-4, "max": 1.0,  "default": 0.01},
            "n_fins": {"type": "int", "min": 0, "max": 200, "default": 10},
            "fin_t": {"type": "float", "min": 1e-5, "max": 0.05, "default": 0.002},
            "fin_h": {"type": "float", "min": 1e-5, "max": 0.2,  "default": 0.01},
            "gap":   {"type": "float", "min": 1e-5, "max": 0.05, "default": 0.002},
        },
    )

    return reg


# =========================================================
# Optional: export helpers (future API outputs)
# =========================================================
def export_cadquery(
    cq_obj: Any,
    out_path: Union[str, Path],
    *,
    fmt: Optional[str] = None,
) -> Path:
    """
    Export a CadQuery object to STEP/STL (or other supported formats).

    Future API idea:
      - POST /cad/export?fmt=step
      - user downloads parametric result to open in CAD tool
    """
    if not cadquery_available():
        raise ImportError("cadquery is not installed.")

    import cadquery as cq

    out_path = Path(out_path).expanduser().resolve()
    out_path.parent.mkdir(parents=True, exist_ok=True)
    fmt = (fmt or out_path.suffix.lstrip(".")).lower()

    if fmt in ("stl", "step", "stp", "amf", "3mf", "svg", "dxf"):
        cq.exporters.export(cq_obj, str(out_path))
    else:
        raise ValueError(f"Unsupported export format: {fmt}")

    return out_path