{
  "repo_root": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple",
  "top_packages": [
    "pinneaple_data",
    "pinneaple_geom",
    "pinneaple_models",
    "pinneaple_pdb",
    "pinneaple_pinn",
    "pinneaple_problemdesign",
    "pinneaple_solvers",
    "pinneaple_timeseries",
    "pinneaple_train"
  ],
  "packages": {
    "pinneaple_data": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_data"
    },
    "pinneaple_geom": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_geom"
    },
    "pinneaple_models": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_models"
    },
    "pinneaple_pdb": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_pdb"
    },
    "pinneaple_pinn": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_pinn"
    },
    "pinneaple_problemdesign": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_problemdesign"
    },
    "pinneaple_solvers": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_solvers"
    },
    "pinneaple_timeseries": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_timeseries"
    },
    "pinneaple_train": {
      "exists": true,
      "package_dir": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\pinneaple_train"
    }
  },
  "files": {
    "pinneaple_data/cache.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/cache.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Hashable",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "collections",
            "level": 0,
            "names": [
              {
                "name": "OrderedDict",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "threading",
            "as": null
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "CacheStats",
            "bases": [],
            "doc": null,
            "class_vars": [
              "evictions",
              "hits",
              "misses"
            ],
            "methods": []
          },
          {
            "name": "LRUCache",
            "bases": [],
            "doc": "Thread-safe LRU cache.\n\nNotes:\n  - max_items is the primary control\n  - you can add your own \"weigher\" if you want max_bytes later",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, max_items)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, key)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "put",
                "signature": "(self, key, value)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "clear",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__len__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/cache_bytes.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/cache_bytes.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Hashable",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "collections",
            "level": 0,
            "names": [
              {
                "name": "OrderedDict",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "threading",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "default_weigher",
            "signature": "(value)",
            "doc": "Estimate memory usage in bytes.\n\n- torch.Tensor: nbytes\n- dict with tensors: sum\n- PhysicalSample-like: sum(fields)+sum(coords)\n- fallback: 1 KB",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ByteCacheStats",
            "bases": [],
            "doc": null,
            "class_vars": [
              "bytes_in_use",
              "evictions",
              "hits",
              "misses"
            ],
            "methods": []
          },
          {
            "name": "ByteLRUCache",
            "bases": [],
            "doc": "Thread-safe LRU cache constrained by max_bytes (not max items).",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, max_bytes, weigher)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, key)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "put",
                "signature": "(self, key, value)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "clear",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__len__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/chunking.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/chunking.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Iterator",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "iter_chunks",
            "signature": "(x, spec)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ChunkSpec",
            "bases": [],
            "doc": "Generic chunking specification for tensors.\n\nBackward-compatible fields:\n  - mode: \"none\" | \"time\" | \"spatial\"  (treated as aliases for axis chunking)\n  - chunk_size: chunk length along the chosen axis\n  - dim: axis to chunk along (default 0)\n\nGeneric extension:\n  - dims: optional multiple axes to chunk along (cartesian tiling)\n  - chunk_sizes: optional per-axis chunk sizes (matches dims length)\n\nRules:\n  - If mode == \"none\": yields the full tensor.\n  - Else, if dims/chunk_sizes are provided: multi-axis chunking.\n  - Else: single-axis chunking using dim/chunk_size.",
            "class_vars": [
              "chunk_size",
              "chunk_sizes",
              "dim",
              "dims",
              "mode"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_data/collate.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/collate.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "_stack_or_cat",
            "signature": "(xs, dim)",
            "doc": "Tries to stack if shapes match perfectly; otherwise concatenates on dim.",
            "decorators": []
          },
          {
            "name": "_collate_tuple_of_tensors",
            "signature": "(items)",
            "doc": "Collate a list of tuples: [(t,x), (t,x), ...] -> (T, X) as concatenated tensors.\nAssumes each element tensor is (N_i, 1) or (N_i, d).\nWe concat along batch dimension (dim=0).",
            "decorators": []
          },
          {
            "name": "collate_pinn_batches",
            "signature": "(batches)",
            "doc": "Collate function compatible with torch DataLoader for PINNFactory batches.\n\nEach batch dict may contain:\n  - \"collocation\": Tuple[Tensor,...]\n  - \"conditions\": List[Tuple[Tensor,...]]\n  - \"data\": (Tuple[Tensor,...], Tensor)\n  - \"meta\": dict\n\nCollation rules:\n  - collocation: concat along dim=0 for each input tensor\n  - conditions: for each condition index, concat along dim=0\n  - data: concat inputs along dim=0, and y_true along dim=0\n  - meta: keep a list of metas (do not merge)",
            "decorators": []
          },
          {
            "name": "move_batch_to_device",
            "signature": "(batch, device)",
            "doc": "Moves all tensors in a collated batch to device.\nLeaves meta unchanged.",
            "decorators": []
          },
          {
            "name": "collate_upd_supervised",
            "signature": "(samples)",
            "doc": "Collate for UPD PhysicalSample supervision batches.\n\nInput: list[PhysicalSample] (or objects with .state dict)\n  each sample.state must have:\n    - \"x\": Tensor (T,D) or (D,) or (T,D,...) (we keep as-is and stack)\n    - optional \"y\": Tensor (T,Do) or (Do,)\n\nOutput dict:\n  - \"x\": Tensor stacked on batch dim -> (B, ...)\n  - optional \"y\": Tensor stacked on batch dim\n  - \"meta\": list[dict] with provenance/domain/schema summary (best-effort)\n  - \"samples\": original samples (optional debug)",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_data/dataloaders.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/dataloaders.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "torch.utils.data",
            "level": 0,
            "names": [
              {
                "name": "DataLoader",
                "as": null
              },
              {
                "name": "Dataset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinneaple_pinn.io",
            "level": 0,
            "names": [
              {
                "name": "UPDItem",
                "as": null
              },
              {
                "name": "UPDDataset",
                "as": null
              },
              {
                "name": "SamplingSpec",
                "as": null
              },
              {
                "name": "ConditionSpec",
                "as": null
              },
              {
                "name": "PINNMapping",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "collate",
            "level": 1,
            "names": [
              {
                "name": "collate_pinn_batches",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "physical_sample",
            "level": 1,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "build_upd_dataloader",
            "signature": "(*, zarr_path, meta_path, mapping, sampling, loader, device, dtype, length)",
            "doc": "Build a DataLoader from a single UPD shard (Zarr+JSON).",
            "decorators": []
          },
          {
            "name": "build_physical_sample_dataloader",
            "signature": "(sample, *, mapping, sampling, loader, device, dtype, length)",
            "doc": "Build a DataLoader from a PhysicalSample.\n\nMVP behavior:\n  - If sample is grid (xarray.Dataset), we create a temporary UPDItem-like wrapper\n    using in-memory ds/meta form supported by UPDDataset.\n  - Mesh samples will be supported later by MeshPhysicalDataset.",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "DataLoaderSpec",
            "bases": [],
            "doc": "Torch DataLoader specification.",
            "class_vars": [
              "batch_size",
              "drop_last",
              "num_workers",
              "pin_memory",
              "shuffle"
            ],
            "methods": []
          },
          {
            "name": "_UPDShardTorchDataset",
            "bases": [
              "Dataset"
            ],
            "doc": "Wraps UPDDataset.sample(spec) into a torch.utils.data.Dataset item generator.\n\nEach __getitem__ returns a dict in the format expected by collate_pinn_batches.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, item, mapping, sampling, device, dtype, length)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__len__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__getitem__",
                "signature": "(self, idx)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/device.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/device.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "_pin",
            "signature": "(x)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_to",
            "signature": "(x, device, dtype, non_blocking)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "pin_sample",
            "signature": "(sample)",
            "doc": "Pins all tensor fields/coords in a PhysicalSample-like object.\n\nSupports:\n  - sample.fields / sample.coords\n  - dict {\"fields\":..., \"coords\":...}",
            "decorators": []
          },
          {
            "name": "to_device_sample",
            "signature": "(sample, device, *, dtype, non_blocking)",
            "doc": "Moves all tensor fields/coords to target device.\n\nSupports:\n  - sample.fields / sample.coords\n  - dict {\"fields\":..., \"coords\":...}",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_data/physical_sample.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/physical_sample.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              },
              {
                "name": "Iterable",
                "as": null
              },
              {
                "name": "Mapping",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "xarray",
            "as": "xr"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PhysicalSample",
            "bases": [],
            "doc": "Unified Physical Sample (UPD-aligned) used across Pinneaple.\n\n- state: xr.Dataset (preferred for gridded data) OR dict-like for non-grid.\n- geometry: GeometryAsset (optional).\n- schema: governing equations, IC/BC, forcings, units policy, etc.\n- domain: how to interpret sample (grid / mesh / graph / points).\n- provenance: lineage (uid, source, query, tiling, time span, etc.)\n- extras: extensibility (feature caches, mesh labels, sdf, etc.)",
            "class_vars": [
              "domain",
              "extras",
              "geometry",
              "provenance",
              "schema",
              "state"
            ],
            "methods": [
              {
                "name": "domain_type",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "is_grid",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "is_mesh",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "is_graph",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list_variables",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "summary",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "to_train_dict",
                "signature": "(self, *, x_vars, y_vars, coords, time_dim)",
                "doc": "Converts this sample into a canonical training dict:\n  {\"x\": <tensor>, \"y\": <tensor?>, \"coords\": {...}, \"meta\": {...}}\n\nNotes:\n- For xr.Dataset, variables are stacked in last dim.\n- For dict-state, assumes each var is already array/tensor-like and stackable.",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/prefetch_adaptive.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/prefetch_adaptive.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Iterator",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "threading",
            "as": null
          },
          {
            "type": "import",
            "name": "queue",
            "as": null
          },
          {
            "type": "import",
            "name": "time",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "torch.utils.data",
            "level": 0,
            "names": [
              {
                "name": "IterableDataset",
                "as": null
              },
              {
                "name": "get_worker_info",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "device",
            "level": 1,
            "names": [
              {
                "name": "pin_sample",
                "as": null
              },
              {
                "name": "to_device_sample",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_cached_store_bytes",
            "level": 1,
            "names": [
              {
                "name": "CachedUPDZarrStoreBytes",
                "as": null
              },
              {
                "name": "ZarrByteCacheConfig",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "AdaptivePrefetchConfig",
            "bases": [],
            "doc": null,
            "class_vars": [
              "control_period_s",
              "decrease_step",
              "high_watermark",
              "increase_step",
              "low_watermark",
              "max_target_fill",
              "min_target_fill",
              "pin_memory",
              "queue_max",
              "target_device",
              "target_fill_init",
              "transfer_non_blocking",
              "use_sample_cache"
            ],
            "methods": []
          },
          {
            "name": "AdaptivePrefetchZarrUPDIterable",
            "bases": [
              "IterableDataset"
            ],
            "doc": "Adaptive prefetching:\n  - queue has fixed max\n  - controller adapts target_fill within [min,max] based on queue occupancy over time",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, root, *, fields, coords, dtype, start, end, stride, sample_ctor, cache, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__iter__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/serialization.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/serialization.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "physical_sample",
            "level": 1,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "save_pt",
            "signature": "(samples, path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "load_pt",
            "signature": "(path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "save_manifest",
            "signature": "(path, manifest)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "load_manifest",
            "signature": "(path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "save_zarr",
            "signature": "(samples, root, *, compressor)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "load_zarr",
            "signature": "(root)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "save_hdf5",
            "signature": "(samples, path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "load_hdf5",
            "signature": "(path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "save_zarr",
            "signature": "(samples, root, *, compressor)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "load_zarr",
            "signature": "(root)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_data/upd_dataset.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/upd_dataset.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Iterator",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "from",
            "module": "physical_sample",
            "level": 1,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "validators",
            "level": 1,
            "names": [
              {
                "name": "validate_physical_sample",
                "as": null
              },
              {
                "name": "assert_valid_physical_sample",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "serialization",
            "level": 1,
            "names": [
              {
                "name": "save_pt",
                "as": null
              },
              {
                "name": "load_pt",
                "as": null
              },
              {
                "name": "save_zarr",
                "as": null
              },
              {
                "name": "load_zarr",
                "as": null
              },
              {
                "name": "save_hdf5",
                "as": null
              },
              {
                "name": "load_hdf5",
                "as": null
              },
              {
                "name": "save_manifest",
                "as": null
              },
              {
                "name": "load_manifest",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "UPDDataset",
            "bases": [],
            "doc": "Hardened dataset wrapper.\n\nFeatures:\n  - schema version in manifest\n  - validation pass\n  - save/load (pt, zarr, hdf5)",
            "class_vars": [
              "manifest",
              "samples"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__len__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__getitem__",
                "signature": "(self, idx)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "validate",
                "signature": "(self, *, units_policy, required_units, ranges, non_negative, monotonic_dims, raise_on_error)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "save",
                "signature": "(self, path, *, format)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "load",
                "signature": "(path, *, format)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/validators.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/validators.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Iterable",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "_is_number",
            "signature": "(x)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "validate_physical_sample",
            "signature": "(sample, *, units_policy, required_units, ranges, non_negative, monotonic_dims)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "assert_valid_physical_sample",
            "signature": "(*args, **kwargs)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ValidationIssue",
            "bases": [],
            "doc": null,
            "class_vars": [
              "field",
              "level",
              "message"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_data/zarr_cached_store.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/zarr_cached_store.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Hashable",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "zarr_store",
            "level": 1,
            "names": [
              {
                "name": "UPDZarrStore",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "cache",
            "level": 1,
            "names": [
              {
                "name": "LRUCache",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_norm_keys",
            "signature": "(keys)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ZarrCacheConfig",
            "bases": [],
            "doc": null,
            "class_vars": [
              "enable_field_cache",
              "max_fields",
              "max_samples"
            ],
            "methods": []
          },
          {
            "name": "CachedUPDZarrStore",
            "bases": [],
            "doc": "Cached wrapper around UPDZarrStore.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, root, *, cache, mode)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "count",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "manifest",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_sample_key",
                "signature": "(self, i, fields, coords, device, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_field_key",
                "signature": "(self, i, kind, name, device, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "read_sample",
                "signature": "(self, i, *, fields, coords, device, dtype, sample_ctor, use_sample_cache)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "cache_stats",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/zarr_cached_store_bytes.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/zarr_cached_store_bytes.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Hashable",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "zarr_store",
            "level": 1,
            "names": [
              {
                "name": "UPDZarrStore",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "cache_bytes",
            "level": 1,
            "names": [
              {
                "name": "ByteLRUCache",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_norm_keys",
            "signature": "(keys)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ZarrByteCacheConfig",
            "bases": [],
            "doc": null,
            "class_vars": [
              "enable_field_cache",
              "max_field_bytes",
              "max_sample_bytes"
            ],
            "methods": []
          },
          {
            "name": "CachedUPDZarrStoreBytes",
            "bases": [],
            "doc": "Cached wrapper around UPDZarrStore using ByteLRUCache.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, root, *, cache, mode)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "count",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "manifest",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_sample_key",
                "signature": "(self, i, fields, coords, device, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_field_key",
                "signature": "(self, i, kind, name, device, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "read_sample",
                "signature": "(self, i, *, fields, coords, device, dtype, sample_ctor, use_sample_cache)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "cache_stats",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/zarr_iterable.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/zarr_iterable.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Iterator",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "torch.utils.data",
            "level": 0,
            "names": [
              {
                "name": "IterableDataset",
                "as": null
              },
              {
                "name": "get_worker_info",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "physical_sample",
            "level": 1,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_store",
            "level": 1,
            "names": [
              {
                "name": "UPDZarrStore",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ZarrUPDIterable",
            "bases": [
              "IterableDataset"
            ],
            "doc": "IterableDataset over a UPDZarrStore.\n\nKey points:\n  - Inherits from torch.utils.data.IterableDataset so DataLoader won't require __len__.\n  - Opens the Zarr store inside __iter__ so each worker has its own handle.\n  - Supports worker-aware sharding (each worker gets disjoint indices).",
            "class_vars": [
              "coords",
              "fields",
              "root",
              "seed",
              "shuffle",
              "start",
              "step",
              "stop"
            ],
            "methods": [
              {
                "name": "__iter__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/zarr_prefetch.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/zarr_prefetch.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Iterator",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "threading",
            "as": null
          },
          {
            "type": "import",
            "name": "queue",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "torch.utils.data",
            "level": 0,
            "names": [
              {
                "name": "IterableDataset",
                "as": null
              },
              {
                "name": "get_worker_info",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_cached_store",
            "level": 1,
            "names": [
              {
                "name": "CachedUPDZarrStore",
                "as": null
              },
              {
                "name": "ZarrCacheConfig",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "device",
            "level": 1,
            "names": [
              {
                "name": "pin_sample",
                "as": null
              },
              {
                "name": "to_device_sample",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PrefetchConfig",
            "bases": [],
            "doc": "Industrial prefetch controls.\n\npin_memory:\n  - If True, producer pins CPU tensors (good for GPU training).\ntarget_device:\n  - If \"cuda\", consumer transfers to GPU using non_blocking=True.\n  - If \"cpu\", yields CPU tensors.\ntransfer_non_blocking:\n  - If True, uses non_blocking transfers (requires pinned memory for full benefit).\nqueue_max:\n  - buffer size between producer and consumer.",
            "class_vars": [
              "pin_memory",
              "prefetch",
              "queue_max",
              "target_device",
              "transfer_non_blocking",
              "use_sample_cache"
            ],
            "methods": []
          },
          {
            "name": "PrefetchZarrUPDIterable",
            "bases": [
              "IterableDataset"
            ],
            "doc": "Streaming dataset backed by Zarr with caching + background prefetch,\nplus pinned memory and async CPU->GPU transfer.\n\nPattern:\n  - Producer thread reads sample from Zarr into CPU tensors (+ optional pin)\n  - Consumer yields either CPU or moved-to-GPU sample (non_blocking)\n\nWorks with DataLoader(num_workers>0):\n  - each worker has its own process-local cache and thread",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, root, *, fields, coords, dtype, start, end, stride, sample_ctor, cache, prefetch_cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__iter__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/zarr_shards.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/zarr_shards.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "import",
            "name": "re",
            "as": null
          },
          {
            "type": "from",
            "module": "zarr_store",
            "level": 1,
            "names": [
              {
                "name": "UPDZarrStore",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_safe_path_component",
            "signature": "(s)",
            "doc": "Make shard keys filesystem-safe (Windows-friendly).\nReplaces invalid/suspicious chars with '_'.",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ShardSpec",
            "bases": [],
            "doc": "Simple shard naming.\n\nExample:\n  key_fn(sample) -> \"time=2020-01\" or \"region=NA\" etc.",
            "class_vars": [
              "key_fn",
              "max_per_shard"
            ],
            "methods": []
          },
          {
            "name": "UPDZarrShardedWriter",
            "bases": [],
            "doc": "Writes multiple shards:\n  root/\n    shards/\n      <key>/part=0000/data.zarr\n      <key>/part=0001/data.zarr\n    index.json\n\nIntended properties:\n  - easy parallelism\n  - easy partial downloads\n  - natural partitioning by time/region/regime",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, root, shard_spec, *, shards_dirname, index_filename)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "write",
                "signature": "(self, samples, *, upd_version, overwrite, chunks)",
                "doc": "Partition samples by shard_spec.key_fn and write each part to its own Zarr store.",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/zarr_shard_iterable.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/zarr_shard_iterable.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Iterator",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "torch.utils.data",
            "level": 0,
            "names": [
              {
                "name": "IterableDataset",
                "as": null
              },
              {
                "name": "get_worker_info",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "device",
            "level": 1,
            "names": [
              {
                "name": "pin_sample",
                "as": null
              },
              {
                "name": "to_device_sample",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_cached_store_bytes",
            "level": 1,
            "names": [
              {
                "name": "CachedUPDZarrStoreBytes",
                "as": null
              },
              {
                "name": "ZarrByteCacheConfig",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_load_index",
            "signature": "(root)",
            "doc": "Returns a flat list of (zarr_path, count) from root/index.json",
            "decorators": []
          },
          {
            "name": "_greedy_balance",
            "signature": "(parts, num_bins)",
            "doc": "Greedy bin packing by count (approx load).",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ShardAwareConfig",
            "bases": [],
            "doc": null,
            "class_vars": [
              "pin_memory",
              "target_device",
              "transfer_non_blocking",
              "use_sample_cache"
            ],
            "methods": []
          },
          {
            "name": "ShardAwareZarrUPDIterable",
            "bases": [
              "IterableDataset"
            ],
            "doc": "Shard-aware iterator:\n  - reads root/index.json\n  - balances shard parts across DataLoader workers\n  - iterates each assigned zarr store sequentially\n\nThis scales well in industry:\n  - natural partitioning\n  - easy parallel reads\n  - balanced work",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, root, *, fields, coords, dtype, sample_ctor, cache, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__iter__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/zarr_store.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/zarr_store.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "import",
            "name": "shutil",
            "as": null
          },
          {
            "type": "import",
            "name": "stat",
            "as": null
          },
          {
            "type": "import",
            "name": "time",
            "as": null
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "asdict",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Iterable",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "zarr",
            "as": null
          },
          {
            "type": "from",
            "module": "physical_sample",
            "level": 1,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_is_torch",
            "signature": "(x)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_to_numpy",
            "signature": "(x)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_rmtree_force",
            "signature": "(path, retries, sleep_s)",
            "doc": "Robust directory removal for Windows (OneDrive/indexer/AV file locks).",
            "decorators": []
          },
          {
            "name": "_atomic_replace_dir",
            "signature": "(tmp_dir, final_dir)",
            "doc": "Atomically replace a directory when possible.\n\nOn Windows, os.replace works for directories too, but can fail if target is open.\nWe fallback to delete+rename.",
            "decorators": []
          },
          {
            "name": "_create_array",
            "signature": "(group, name, data, chunks)",
            "doc": "Zarr v2/v3 compatibility wrapper.\nIMPORTANT: do NOT pass chunks=None to Zarr v3.",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "UPDZarrStore",
            "bases": [],
            "doc": "Minimal UPD Zarr store:\n\nroot/\n  fields/\n    <field_name> : array with shape (N, ...)  (N = number of samples)\n  coords/  (optional)\n  meta/\n    manifest.json (optional)\n    info attrs\n\nThis store assumes a \"columnar\" layout: each field is stacked across samples.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, root, mode)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "write",
                "signature": "(root, samples, manifest, *, overwrite, chunks)",
                "doc": "Write samples to a Zarr directory store.\n\n- Writes to <root>.tmp then atomically replaces <root>.\n- Creates required group 'fields' and stacks each field across samples.",
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "num_samples",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "field_names",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "read_sample",
                "signature": "(self, idx, *, fields)",
                "doc": "Read one sample from stacked field arrays.",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/__init__.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "physical_sample",
            "level": 1,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "upd_dataset",
            "level": 1,
            "names": [
              {
                "name": "UPDDataset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "collate",
            "level": 1,
            "names": [
              {
                "name": "collate_pinn_batches",
                "as": null
              },
              {
                "name": "move_batch_to_device",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataloaders",
            "level": 1,
            "names": [
              {
                "name": "build_upd_dataloader",
                "as": null
              },
              {
                "name": "build_physical_sample_dataloader",
                "as": null
              },
              {
                "name": "DataLoaderSpec",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "validators",
            "level": 1,
            "names": [
              {
                "name": "validate_physical_sample",
                "as": null
              },
              {
                "name": "assert_valid_physical_sample",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "chunking",
            "level": 1,
            "names": [
              {
                "name": "ChunkSpec",
                "as": null
              },
              {
                "name": "iter_chunks",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_iterable",
            "level": 1,
            "names": [
              {
                "name": "ZarrUPDIterable",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_shards",
            "level": 1,
            "names": [
              {
                "name": "ShardSpec",
                "as": null
              },
              {
                "name": "UPDZarrShardedWriter",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_store",
            "level": 1,
            "names": [
              {
                "name": "UPDZarrStore",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_cached_store",
            "level": 1,
            "names": [
              {
                "name": "CachedUPDZarrStore",
                "as": null
              },
              {
                "name": "ZarrCacheConfig",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_prefetch",
            "level": 1,
            "names": [
              {
                "name": "PrefetchZarrUPDIterable",
                "as": null
              },
              {
                "name": "PrefetchConfig",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "device",
            "level": 1,
            "names": [
              {
                "name": "pin_sample",
                "as": null
              },
              {
                "name": "to_device_sample",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "cache_bytes",
            "level": 1,
            "names": [
              {
                "name": "ByteLRUCache",
                "as": null
              },
              {
                "name": "ByteCacheStats",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_cached_store_bytes",
            "level": 1,
            "names": [
              {
                "name": "CachedUPDZarrStoreBytes",
                "as": null
              },
              {
                "name": "ZarrByteCacheConfig",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "prefetch_adaptive",
            "level": 1,
            "names": [
              {
                "name": "AdaptivePrefetchZarrUPDIterable",
                "as": null
              },
              {
                "name": "AdaptivePrefetchConfig",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "zarr_shard_iterable",
            "level": 1,
            "names": [
              {
                "name": "ShardAwareZarrUPDIterable",
                "as": null
              },
              {
                "name": "ShardAwareConfig",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_data/adapters/geom_adapter.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/adapters/geom_adapter.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              },
              {
                "name": "overload",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_is_pathlike",
            "signature": "(x)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_default_spec_from_path",
            "signature": "(p)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "load_geometry_asset",
            "signature": "(geom, *, options)",
            "doc": "Loads/creates a GeometryAsset using pinneaple_geom.\n\nReturns:\n  GeometryAsset (opaque here; defined in pinneaple_geom)\n\nSupported inputs:\n  - Path/str: inferred spec by file extension\n  - dict: GeometrySpec-like\n  - GeometryAsset: returned as-is",
            "decorators": []
          },
          {
            "name": "attach_geometry",
            "signature": "(sample, geom_asset)",
            "doc": "Attaches a GeometryAsset to a PhysicalSample-like object.\n\nExpects `sample` to have `.geometry` and `.domain` (dict) or be dict-like.\n\nThis keeps things flexible while we iterate on the PhysicalSample dataclass.",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "GeometryLoadOptions",
            "bases": [],
            "doc": "Options for geometry/mesh loading and basic processing.\n\nThis MVP focuses on:\n  - fast load (trimesh/meshio)\n  - basic transforms\n  - optional simplification hooks (for later)\n\nNote: operations such as remeshing/decimation are expected to live in pinneaple_geom.ops.",
            "class_vars": [
              "boundary_labels",
              "compute_normals",
              "repair",
              "rotate_euler_deg",
              "scale",
              "translate"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_data/adapters/upd_adapter.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/adapters/upd_adapter.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "xarray",
            "as": "xr"
          }
        ],
        "functions": [
          {
            "name": "load_upd_item",
            "signature": "(upd)",
            "doc": "Load UPD shard data (Zarr) and metadata (JSON).\n\nSupports:\n  - (zarr_path, meta_path)\n  - {\"zarr_path\":..., \"meta_path\":...}\n  - UPDItem-like object (has open_dataset/load_meta)\n  - (Dataset, meta_dict) packed in dict: {\"ds\":..., \"meta\":...}",
            "decorators": []
          },
          {
            "name": "_load_paths",
            "signature": "(zarr_path, meta_path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_infer_domain_from_upd",
            "signature": "(ds)",
            "doc": "Domain inference for UPD grid shards.\n\nTypical coords:\n  - time, lat, lon, (optional lev)",
            "decorators": []
          },
          {
            "name": "upd_to_physical_sample",
            "signature": "(upd, *, schema_override, provenance_extra)",
            "doc": "Creates a PhysicalSample from a UPD shard (Zarr+JSON).\n\nRequires `pinneaple_data.physical_sample.PhysicalSample` to exist.\n\nReturns:\n  PhysicalSample\n\nIf you haven't created PhysicalSample yet, this will raise ImportError.",
            "decorators": []
          },
          {
            "name": "attach_upd_state",
            "signature": "(sample, upd)",
            "doc": "Attaches UPD state (xarray.Dataset) and schema/domain/provenance into an existing sample.\n\nWorks with:\n  - PhysicalSample-like object (attributes)\n  - dict-like sample",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_data/adapters/__init__.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/adapters/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "geom_adapter",
            "level": 1,
            "names": [
              {
                "name": "GeometryInput",
                "as": null
              },
              {
                "name": "GeometryLoadOptions",
                "as": null
              },
              {
                "name": "load_geometry_asset",
                "as": null
              },
              {
                "name": "attach_geometry",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "upd_adapter",
            "level": 1,
            "names": [
              {
                "name": "UPDInput",
                "as": null
              },
              {
                "name": "load_upd_item",
                "as": null
              },
              {
                "name": "upd_to_physical_sample",
                "as": null
              },
              {
                "name": "attach_upd_state",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_data/synth/base.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Protocol",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "SynthConfig",
            "bases": [],
            "doc": null,
            "class_vars": [
              "device",
              "dtype",
              "seed"
            ],
            "methods": []
          },
          {
            "name": "SynthOutput",
            "bases": [],
            "doc": null,
            "class_vars": [
              "extras",
              "samples"
            ],
            "methods": []
          },
          {
            "name": "SynthGenerator",
            "bases": [
              "Protocol"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "generate",
                "signature": "(self, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/curvefit.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/curvefit.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SynthConfig",
                "as": null
              },
              {
                "name": "SynthOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pde",
            "level": 1,
            "names": [
              {
                "name": "SimplePhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_poly_features",
            "signature": "(x, degree)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "CurveFitSynthGenerator",
            "bases": [],
            "doc": "Learn a curve/trend from a dataset and synthesize missing values or densify sampling.\n\nMVP:\n  - assumes you provide 1D input x and target y\n  - fits polynomial regression (ridge)\n  - generates new points and returns filled dataset",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, *, x, y, degree, ridge, n_new, x_range, noise_std, mask_missing)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/distributions.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/distributions.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SynthConfig",
                "as": null
              },
              {
                "name": "SynthOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pde",
            "level": 1,
            "names": [
              {
                "name": "SimplePhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "DistributionSynthGenerator",
            "bases": [],
            "doc": "Generate synthetic samples from distributions:\n  - gaussian, uniform\n  - mixture of gaussians (simple)\nOutput as PhysicalSample-like objects: fields={\"x\":..., \"y\":...} etc.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_rng",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, *, kind, n_samples, dim, mean, std, low, high, mixture_means, mixture_stds, mixture_weights, y_fn)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/geometry.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/geometry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "math",
            "as": null
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SynthConfig",
                "as": null
              },
              {
                "name": "SynthOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pde",
            "level": 1,
            "names": [
              {
                "name": "SimplePhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "GeometrySynthGenerator",
            "bases": [],
            "doc": "Geometry synthesis/augmentation from an existing mesh (e.g., STL).\n\nMVP:\n  - expects a trimesh.Trimesh-like object OR dict with vertices/faces\n  - generates N variants preserving similarity\n\nOperations (controlled by params):\n  - uniform scale in [smin, smax]\n  - axis scale (sx,sy,sz) ranges\n  - small random rotation\n  - vertex noise (smooth-ish) with amplitude",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_rng",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_extract",
                "signature": "(self, mesh)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_rot_matrix",
                "signature": "(self, rx, ry, rz)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, *, mesh, n_variants, scale_range, axis_scale_range, rot_deg, noise_amp, keep_centered)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/geometry_cadquery.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/geometry_cadquery.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "math",
            "as": null
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SynthConfig",
                "as": null
              },
              {
                "name": "SynthOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "sample_adapter",
            "level": 1,
            "names": [
              {
                "name": "to_physical_sample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_try_import_cadquery",
            "signature": "()",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_try_import_trimesh",
            "signature": "()",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_mesh_from_cq_solid",
            "signature": "(cq, solid, *, linear_deflection, angular_deflection)",
            "doc": "Convert a CadQuery solid to a triangle mesh (trimesh) if available, else numpy arrays.",
            "decorators": []
          },
          {
            "name": "_extract_mesh_arrays",
            "signature": "(mesh)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_bbox_params",
            "signature": "(V)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ParametricCadQuerySynthGenerator",
            "bases": [],
            "doc": "Generate geometry variants from a parametric CadQuery template.\n\nYou provide:\n  - template_fn(params) -> cadquery.Workplane or Shape\n  - param_ranges: {name: (lo, hi)}\n  - n_variants\n\nOutput samples:\n  fields: vertices (N,3), faces (F,3), params (dict)\n  meta: template name, ranges",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, *, template_fn, param_ranges, n_variants, tess_linear_deflection, tess_angular_deflection, seed_offset, name)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "STLTemplateSynthGenerator",
            "bases": [],
            "doc": "Fallback generator:\n  - takes an STL/mesh, infers bbox,\n  - optionally builds a simple parametric CadQuery primitive matching bbox,\n  - or falls back to vertex-space augmentation if cadquery missing.\n\nTemplates (when cadquery exists):\n  - \"box\": length/width/height\n  - \"cylinder\": radius/height (radius inferred from xy bbox)\n  - \"capsule\": radius/height (approx)\n\nIf cadquery not available:\n  - does similarity-preserving transforms (scale/axis-scale/rot/noise) on original mesh vertices.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_load_mesh",
                "signature": "(self, mesh_or_path)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, *, mesh_or_path, n_variants, template, param_jitter, rot_deg, noise_amp, tess_linear_deflection, tess_angular_deflection, seed_offset, name)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/images.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/images.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SynthConfig",
                "as": null
              },
              {
                "name": "SynthOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pde",
            "level": 1,
            "names": [
              {
                "name": "SimplePhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_as_tensor",
            "signature": "(img, device, dtype)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_smooth2d",
            "signature": "(x)",
            "doc": "Simple 2D smoothing via neighbor averaging.\nx: (H,W) or (C,H,W)",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ImageReconstructionSynthGenerator",
            "bases": [],
            "doc": "Image reconstruction / synthesis generator.\n\nMVP modes:\n  - \"inpaint_smooth\": iterative smoothing inside masked region\n  - \"autoencoder\": use provided AE model to reconstruct\n\nInput:\n  img: (H,W) or (C,H,W)\n  mask: same spatial shape (H,W) bool or 0/1\n    mask==1 means MISSING region to reconstruct",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, *, img, mask, mode, steps, ae_model, post_fn)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/pde.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/pde.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "math",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SynthConfig",
                "as": null
              },
              {
                "name": "SynthOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "SimplePhysicalSample",
            "bases": [],
            "doc": "MVP duck-typed PhysicalSample to keep synth module usable standalone.\nReplace with your pinneaple_data.physical_sample.PhysicalSample later.",
            "class_vars": [
              "coords",
              "fields",
              "meta"
            ],
            "methods": []
          },
          {
            "name": "PDESynthGenerator",
            "bases": [],
            "doc": "PDE/ODE synthetic generator.\n\nMVP supports:\n  - 1D heat equation: u_t = alpha u_xx\n  - 1D advection:     u_t + c u_x = 0\n  - ODE logistic:     u' = r u (1-u/K)\n\nProvide:\n  kind: \"heat1d\" | \"advection1d\" | \"logistic\"\n  domain/grid/time params\n  initial condition function",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_rng",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, *, kind, n_samples, dt, steps, x_min, x_max, nx, bc, alpha, c, r, K, ic_fn)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/pde_symbolic.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/pde_symbolic.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "math",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SynthConfig",
                "as": null
              },
              {
                "name": "SynthOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "sample_adapter",
            "level": 1,
            "names": [
              {
                "name": "to_physical_sample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_safe_import_sympy",
            "signature": "()",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_fd_u_x",
            "signature": "(u, dx, bc)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_fd_u_xx",
            "signature": "(u, dx, bc)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_build_rhs_from_equation",
            "signature": "(equation, *, parameters)",
            "doc": "Returns rhs(u, t, x, derivs) = u_t as tensor.\nSupported symbolic tokens:\n  - u, u_t, u_x, u_xx\n  - t, x\n  - named params (alpha, c, nu, etc.) from `parameters`\n  - basic funcs: sin, cos, exp, pi",
            "decorators": []
          },
          {
            "name": "make_fd_residual_fn",
            "signature": "(equation, *, parameters, bc)",
            "doc": "Returns residual(u, t, x, dt, dx) -> tensor residual over (T,X)\n\nu: (T, X) or (B, T, X)\nt: (T,)\nx: (X,)",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "SymbolicFDSynthGenerator",
            "bases": [],
            "doc": "Symbolic equation -> automatic finite difference operator -> synthetic dataset.\n\nInputs:\n  equation: string residual form, e.g. \"u_t - alpha*u_xx\"\n  parameters: dict with alpha,c,nu,... numeric\n  ic_fn: function(x, rng)->u0(x)\n\nOutput:\n  PhysicalSample (if available) or fallback\n  fields:\n    - \"u\": (T+1, X)\n  coords:\n    - \"t\": (T+1,)\n    - \"x\": (X,)\n  meta:\n    - equation, parameters, dt, dx, bc\n  extras:\n    - rhs_fn (callable)\n    - residual_fn (callable)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_rng",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, *, equation, parameters, n_samples, dt, steps, x_min, x_max, nx, bc, ic_fn, store_residual)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/registry.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pde",
            "level": 1,
            "names": [
              {
                "name": "PDESynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "distributions",
            "level": 1,
            "names": [
              {
                "name": "DistributionSynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "curvefit",
            "level": 1,
            "names": [
              {
                "name": "CurveFitSynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "images",
            "level": 1,
            "names": [
              {
                "name": "ImageReconstructionSynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "geometry",
            "level": 1,
            "names": [
              {
                "name": "GeometrySynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pde_symbolic",
            "level": 1,
            "names": [
              {
                "name": "SymbolicFDSynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "geometry_cadquery",
            "level": 1,
            "names": [
              {
                "name": "STLTemplateSynthGenerator",
                "as": null
              },
              {
                "name": "ParametricCadQuerySynthGenerator",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "SynthCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_data/synth/sample_adapter.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/sample_adapter.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Protocol",
                "as": null
              },
              {
                "name": "runtime_checkable",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "has_pinnego_physical_sample",
            "signature": "()",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_torchify_tree",
            "signature": "(obj, *, device, dtype)",
            "doc": "Convert numpy/lists -> torch.Tensor recursively when possible.\nKeeps non-tensor metadata as is.",
            "decorators": []
          },
          {
            "name": "to_physical_sample",
            "signature": "(sample_like, *, device, dtype)",
            "doc": "Best-effort conversion:\n  - if already a PhysicalSample -> return\n  - if duck-typed {fields, coords, meta} -> convert\n  - else if dict with keys -> interpret\n\nReturns:\n  - pinneaple_data.physical_sample.PhysicalSample if available\n  - else returns a minimal dataclass fallback (SynthPhysicalSample)",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "PhysicalSampleLike",
            "bases": [
              "Protocol"
            ],
            "doc": null,
            "class_vars": [
              "coords",
              "fields",
              "meta"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_data/synth/__init__.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SynthGenerator",
                "as": null
              },
              {
                "name": "SynthOutput",
                "as": null
              },
              {
                "name": "SynthConfig",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "SynthCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pde",
            "level": 1,
            "names": [
              {
                "name": "PDESynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "distributions",
            "level": 1,
            "names": [
              {
                "name": "DistributionSynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "curvefit",
            "level": 1,
            "names": [
              {
                "name": "CurveFitSynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "images",
            "level": 1,
            "names": [
              {
                "name": "ImageReconstructionSynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "geometry",
            "level": 1,
            "names": [
              {
                "name": "GeometrySynthGenerator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "sample_adapter",
            "level": 1,
            "names": [
              {
                "name": "has_pinnego_physical_sample",
                "as": null
              },
              {
                "name": "to_physical_sample",
                "as": null
              },
              {
                "name": "PhysicalSampleLike",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pde_symbolic",
            "level": 1,
            "names": [
              {
                "name": "SymbolicFDSynthGenerator",
                "as": null
              },
              {
                "name": "make_fd_residual_fn",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "geometry_cadquery",
            "level": 1,
            "names": [
              {
                "name": "ParametricCadQuerySynthGenerator",
                "as": null
              },
              {
                "name": "STLTemplateSynthGenerator",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_data/synth/operators/masks.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/operators/masks.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "random_block_mask",
            "signature": "(H, W, frac, seed)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_data/synth/operators/noise.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/operators/noise.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "add_gaussian_noise",
            "signature": "(x, std, seed)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_data/synth/operators/transforms.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/operators/transforms.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "normalize_01",
            "signature": "(x, eps)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_data/synth/operators/__init__.py": {
      "package": "pinneaple_data",
      "path": "pinneaple_data/synth/operators/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "noise",
            "level": 1,
            "names": [
              {
                "name": "add_gaussian_noise",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "masks",
            "level": 1,
            "names": [
              {
                "name": "random_block_mask",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "transforms",
            "level": 1,
            "names": [
              {
                "name": "normalize_01",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_geom/__init__.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/__init__.py",
      "parsed": {
        "doc": "pinneaple_geom\n\nGeometry + mesh utilities for Pinneaple.\n\nMVP-1 focus (trimesh + meshio):\n- Load geometry files (STL/OBJ/PLY/GLTF/...)\n- Load mesh files (VTK/VTU/MSH/...)\n- Generate simple parametric primitives -> meshes\n- Apply fast transforms (scale/translate/rotate)\n- Provide surface sampling hooks for PINN collocation/BC points\n\nDesign principles:\n- Keep `pinneaple_geom` independent from `pinneaple_pdb` (ETL) and `pinneaple_pinn` (loss/models)\n- Expose a small stable API surface from `__init__`",
        "imports": [
          {
            "type": "from",
            "module": "core.geometry",
            "level": 1,
            "names": [
              {
                "name": "GeometrySpec",
                "as": null
              },
              {
                "name": "GeometryAsset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "core.mesh",
            "level": 1,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "core.registry",
            "level": 1,
            "names": [
              {
                "name": "build_geometry_asset",
                "as": null
              },
              {
                "name": "load_geometry_asset",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_geom/core/geometry.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/core/geometry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "hashlib",
            "as": null
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          }
        ],
        "functions": [
          {
            "name": "_as_np3",
            "signature": "(x, name)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_stable_json",
            "signature": "(obj)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_hash_bytes",
            "signature": "(data, algo)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_hash_array",
            "signature": "(a, algo)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_compute_bounds",
            "signature": "(vertices)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_apply_transform",
            "signature": "(vertices, T)",
            "doc": "Apply 4x4 homogeneous transform to (N,3) vertices.",
            "decorators": []
          },
          {
            "name": "_normalize_vecs",
            "signature": "(x, eps)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_face_normals",
            "signature": "(vertices, faces)",
            "doc": "Compute per-face normals for triangular faces (M,3 int indices).",
            "decorators": []
          },
          {
            "name": "_vertex_normals",
            "signature": "(vertices, faces)",
            "doc": "Simple angle-unaware vertex normals: accumulate adjacent face normals.",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "GeometrySpec",
            "bases": [],
            "doc": "Declarative geometry specification.\n\nExamples:\n  {\"kind\":\"primitive\",\"name\":\"box\",\"params\":{...}}\n  {\"kind\":\"file\",\"path\":\"model.stl\"}\n  {\"kind\":\"mesh_file\",\"path\":\"case.vtu\"}\n\nImprovements:\n  - validation (basic)\n  - stable fingerprinting for caching/manifests\n  - small convenience helpers",
            "class_vars": [
              "kind",
              "name",
              "params",
              "path"
            ],
            "methods": [
              {
                "name": "validate",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "to_dict",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fingerprint",
                "signature": "(self, algo)",
                "doc": "Stable hash of the declarative spec, useful for cache keys.",
                "decorators": []
              },
              {
                "name": "is_file_backed",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "GeometryAsset",
            "bases": [],
            "doc": "Unified geometry container used across Pinneaple.\n\nHolds a MeshData + metadata and optional boundary groups.\n\nAttributes:\n  - mesh: MeshData (expects .vertices (N,3), .faces (M,3))\n  - bounds: (min_xyz, max_xyz)\n  - units: optional physical units (e.g. meters)\n  - boundary_groups: semantic labels (inlet/outlet/wall/etc.)\n  - meta: free metadata (source, transforms applied, hashes)\n\nImprovements:\n  - recompute bounds / normalization\n  - transforms (translate/scale/affine 4x4)\n  - lightweight geometry fingerprints (verts/faces)\n  - optional normal computation (face/vertex)\n  - boundary group convenience helpers\n  - safe \"manifest\" summary for storage (e.g., Zarr index)",
            "class_vars": [
              "boundary_groups",
              "bounds",
              "mesh",
              "meta",
              "units"
            ],
            "methods": [
              {
                "name": "bbox_size",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "center",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "recompute_bounds",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "ensure_bounds",
                "signature": "(self)",
                "doc": "If bounds look invalid, recompute. (Useful after manual mesh edits.)",
                "decorators": []
              },
              {
                "name": "mesh_fingerprint",
                "signature": "(self, algo)",
                "doc": "Hash based on vertices + faces. Great for caching pipelines.",
                "decorators": []
              },
              {
                "name": "record_fingerprint",
                "signature": "(self, key, algo)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "apply_transform",
                "signature": "(self, T, record)",
                "doc": "Apply 4x4 transform to vertices (and recompute bounds).",
                "decorators": []
              },
              {
                "name": "translate",
                "signature": "(self, delta_xyz, record)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "scale",
                "signature": "(self, s, about, record)",
                "doc": "Uniform scale by s, optionally about a point (default: origin).",
                "decorators": []
              },
              {
                "name": "normalize_to_unit_box",
                "signature": "(self, target_size, center_to_origin, eps, record)",
                "doc": "Normalize geometry to fit inside a cube of edge 'target_size'.\nUseful for stable training + batching.\n\nReturns info dict with scale and original bounds.",
                "decorators": []
              },
              {
                "name": "ensure_normals",
                "signature": "(self, kind)",
                "doc": "Compute normals if mesh doesn't have them.\n\nkind: \"face\" or \"vertex\"",
                "decorators": []
              },
              {
                "name": "add_boundary_group",
                "signature": "(self, name, data)",
                "doc": "Example: group \"inlet\" -> {face_ids:[...]} or {vertex_ids:[...]} or mask arrays.",
                "decorators": []
              },
              {
                "name": "list_boundary_groups",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get_boundary_group",
                "signature": "(self, name, default)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "manifest",
                "signature": "(self)",
                "doc": "Storage-friendly metadata (no huge arrays). Good for Zarr inspector/manifests.",
                "decorators": []
              },
              {
                "name": "summary",
                "signature": "(self)",
                "doc": "Backwards-compatible summary (keeps your original keys)\n+ adds a couple extra low-cost fields.",
                "decorators": []
              },
              {
                "name": "from_mesh",
                "signature": "(cls, mesh, units, boundary_groups, meta, record_fp)",
                "doc": null,
                "decorators": [
                  "classmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_geom/core/mesh.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/core/mesh.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Iterator",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "hashlib",
            "as": null
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "MeshData",
            "bases": [],
            "doc": "Lightweight mesh container (numpy-only).\n\nvertices: (N,3) float64\nfaces:    (M,3) int64 (triangle mesh)\nnormals:  (M,3) or (N,3), optional\n\nPINN-ready additions:\n  - collocation samplers:\n      * sample_surface(n)\n      * sample_interior(n, inside_fn=..., sdf_fn=..., domain=\"mesh|bbox\")\n      * sample_collocation(...)\n  - boundary groups from bbox planes (inlet/outlet/wall-like):\n      * boundary_groups_bbox(...)\n  - Monte Carlo integration helpers:\n      * mc_integral_weights(...)\n  - batching utilities:\n      * iter_batches(...)",
            "class_vars": [
              "faces",
              "normals",
              "vertices"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_validate",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "n_vertices",
                "signature": "(self)",
                "doc": null,
                "decorators": [
                  "property"
                ]
              },
              {
                "name": "n_faces",
                "signature": "(self)",
                "doc": null,
                "decorators": [
                  "property"
                ]
              },
              {
                "name": "bounds",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "bbox_size",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "center",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "apply_transform",
                "signature": "(self, matrix, update_normals)",
                "doc": "Apply 4x4 homogeneous transform in-place.",
                "decorators": []
              },
              {
                "name": "translate",
                "signature": "(self, delta)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "scale",
                "signature": "(self, factor, about)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "normalize_to_unit_box",
                "signature": "(self)",
                "doc": "Center to origin and scale so largest bbox dimension = 1.\nReturns applied scale.",
                "decorators": []
              },
              {
                "name": "_normalize",
                "signature": "(x)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "_normalize_normals",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "compute_face_normals",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "compute_vertex_normals",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "ensure_normals",
                "signature": "(self, mode)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "face_areas",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "surface_area",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "volume_bbox",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "sample_surface",
                "signature": "(self, n, return_face_ids)",
                "doc": "Uniform random sampling over surface area.\nReturns points (N,3). Optionally also returns face_ids (N,).",
                "decorators": []
              },
              {
                "name": "sample_bbox",
                "signature": "(self, n, bounds)",
                "doc": "Sample uniformly inside a bounding box (default: mesh bbox).",
                "decorators": []
              },
              {
                "name": "sample_interior",
                "signature": "(self, n, *, domain, inside_fn, sdf_fn, bounds, max_tries)",
                "doc": "Sample collocation points in the interior domain.\n\ndomain:\n  - \"bbox\": interior is the bounding box (works without any extra info)\n  - \"mesh\": requires inside_fn or sdf_fn (numpy-only) to test inside\n\nPrefer sdf_fn if you have it (negative inside). Otherwise inside_fn boolean.\n\nIf domain=\"mesh\" and no inside/sdf is given, it falls back to bbox.",
                "decorators": []
              },
              {
                "name": "boundary_groups_bbox",
                "signature": "(self, tol, *, names)",
                "doc": "Build simple boundary groups using bbox planes.\n\nReturns dict like:\n  {\n    \"xmin\": {\"vertex_ids\": ..., \"mask\": ...},\n    ...\n  }\n\nUseful when your PDE domain is box-like or you need quick inlet/outlet/walls.",
                "decorators": []
              },
              {
                "name": "sample_collocation",
                "signature": "(self, n_interior, n_boundary, *, interior_domain, inside_fn, sdf_fn, boundary_mode, boundary_groups, bounds)",
                "doc": "Returns a dict ready for PINN batching.\n\nboundary_mode:\n  - \"surface\": boundary points sampled from mesh surface (triangle sampling)\n  - \"bbox_planes\": boundary points sampled on bbox planes (fast box BCs)\n\nIf boundary_groups is provided, will also return:\n  - \"bnd_group_id\" (N,) int64, mapping each boundary point to group index\n  - \"bnd_group_name\" as an array of fixed-length strings (optional convenience)",
                "decorators": []
              },
              {
                "name": "mc_integral_weights",
                "signature": "(self, X, *, domain_volume, mask)",
                "doc": "Returns per-sample weights for MC integral approximation:\n   f(x) dx  sum_i w_i f(x_i)\n\nIf mask is provided, weights apply only to masked points (others 0).",
                "decorators": []
              },
              {
                "name": "iter_batches",
                "signature": "(self, X, batch_size, *, shuffle, seed)",
                "doc": "Yield mini-batches of X (N,D). Numpy-only.",
                "decorators": []
              },
              {
                "name": "fingerprint",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "copy",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_geom/core/registry.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/core/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "geometry",
            "level": 1,
            "names": [
              {
                "name": "GeometrySpec",
                "as": null
              },
              {
                "name": "GeometryAsset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "mesh",
            "level": 1,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_rotation_matrix_xyz",
            "signature": "(rx, ry, rz)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_ensure_vec3",
            "signature": "(x, name)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_guess_kind_from_path",
            "signature": "(p)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_maybe_fix_normals",
            "signature": "(mesh, prefer)",
            "doc": "If normals are missing or ill-shaped, compute (numpy-only).",
            "decorators": []
          },
          {
            "name": "_load_trimesh_from_file",
            "signature": "(path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_meshdata_from_trimesh",
            "signature": "(tm)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_meshdata_from_meshio",
            "signature": "(mesh)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_get_opt",
            "signature": "(options, key, default)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_apply_options",
            "signature": "(mesh, options)",
            "doc": "Apply transforms and mesh hygiene steps in a controlled order.\n\nReturns meta dict of what was applied (safe for manifest).",
            "decorators": []
          },
          {
            "name": "build_geometry_asset",
            "signature": "(spec, *, options)",
            "doc": "Build a GeometryAsset from a GeometrySpec or spec dict.\n\nSupported kinds:\n  - file       (STL/OBJ/PLY/GLTF/OFF) via trimesh\n  - mesh_file  (VTK/VTU/MSH/...) via meshio\n  - primitive  (delegated to pinneaple_geom.gen.primitives)\n\nImprovements:\n  - spec.validate() when available\n  - robust meta (fingerprints, transforms applied)\n  - optional normalization/centering/hygiene\n  - normals handling\n  - boundary group helpers passthrough",
            "decorators": []
          },
          {
            "name": "load_geometry_asset",
            "signature": "(geom, *, options)",
            "doc": "Convenience wrapper:\n  - Path / str -> infer spec\n  - GeometryAsset -> returned as-is\n  - dict -> GeometrySpec\n\nImprovements:\n  - supports already-built GeometrySpec\n  - better kind inference\n  - keeps backward behavior",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/core/__init__.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/core/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "geometry",
            "level": 1,
            "names": [
              {
                "name": "GeometrySpec",
                "as": null
              },
              {
                "name": "GeometryAsset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "mesh",
            "level": 1,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "build_geometry_asset",
                "as": null
              },
              {
                "name": "load_geometry_asset",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_geom/gen/cadquery_gen.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/gen/cadquery_gen.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "cadquery_available",
            "signature": "()",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_tm_to_meshdata",
            "signature": "(tm)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "cadquery_to_trimesh",
            "signature": "(cq_obj, *, options)",
            "doc": "Convert an in-memory CadQuery object (Workplane/Solid/Compound) to trimesh.Trimesh.\n\nMVP approach:\n  - export to a temporary STL\n  - load with trimesh (robust and avoids binding to CQ internals)\n\nFuture-ready notes:\n  - We keep 'options' so we can swap to direct tessellation later.\n  - We return trimesh for validation/repair in future (watertight checks, etc).",
            "decorators": []
          },
          {
            "name": "build_mesh_from_step",
            "signature": "(step_path, *, options)",
            "doc": "Load a STEP file with CadQuery and return a triangle mesh as MeshData.\n\nNote:\n  STEP is \"non-parametric\" here (just a shape). This supports uploads.\n  Parametric edits are achieved via ParametricCadSpec + registry builder recipes.",
            "decorators": []
          },
          {
            "name": "build_mesh_from_cadquery_object",
            "signature": "(cq_obj, *, options)",
            "doc": "Convert an in-memory CadQuery object (Workplane/Solid/Compound) to MeshData.",
            "decorators": []
          },
          {
            "name": "build_mesh_from_parametric_spec",
            "signature": "(spec, registry, *, options)",
            "doc": "Build a MeshData from a ParametricCadSpec using a registry builder.\n\nThis is the \"future API\" hook:\n  POST /cad/build {builder_id, params} -> returns mesh (or saved asset id)",
            "decorators": []
          },
          {
            "name": "register_default_templates",
            "signature": "(reg)",
            "doc": "Register a couple of templates to prove the concept.\n(You can add your cold-plate / channel / fin arrays here.)",
            "decorators": []
          },
          {
            "name": "export_cadquery",
            "signature": "(cq_obj, out_path, *, fmt)",
            "doc": "Export a CadQuery object to STEP/STL (or other supported formats).\n\nFuture API idea:\n  - POST /cad/export?fmt=step\n  - user downloads parametric result to open in CAD tool",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "CadQueryTessellationOptions",
            "bases": [],
            "doc": "CadQuery tessellation controls (affect mesh fidelity and speed).\n\nSmaller deflection => more triangles (slower, higher fidelity)",
            "class_vars": [
              "angular_deflection",
              "linear_deflection"
            ],
            "methods": []
          },
          {
            "name": "ParametricCadSpec",
            "bases": [],
            "doc": "Future-ready declarative CAD spec.\n\nGoal:\n  - User can upload a non-parametric CAD (STEP/STL) for visualization/meshing.\n  - But ALSO you can expose parametric \"recipes\" (CadQuery builders) that\n    can be re-generated by changing params (API-friendly).\n\n'builder_id' points to a registered CadQuery builder function.\n'params' holds the user-chosen values.\n'schema' describes min/max/type/default so a frontend can render sliders/inputs.",
            "class_vars": [
              "builder_id",
              "meta",
              "params",
              "schema"
            ],
            "methods": [
              {
                "name": "validate",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "with_defaults",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "CadQueryBuildOptions",
            "bases": [],
            "doc": "Build controls beyond tessellation.\n\n- heal: attempt to clean/validate solids after import (future hook)\n- center_to_origin: convenience for simulation standardization\n- normalize_to_unit_box: convenience for ML batching (if desired)",
            "class_vars": [
              "center_to_origin",
              "heal",
              "normalize_to_unit_box",
              "tessellation"
            ],
            "methods": []
          },
          {
            "name": "CadQueryRegistry",
            "bases": [],
            "doc": "Registry of parametric CAD builders.\n\nThis is the missing piece for your future API:\n  - upload STL/STEP -> store as a \"baseline asset\"\n  - user selects a template (builder_id) -> params become editable\n  - rebuild geometry with CadQuery -> mesh -> run new simulation",
            "class_vars": [
              "builders",
              "schemas"
            ],
            "methods": [
              {
                "name": "register",
                "signature": "(self, builder_id, builder, schema)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get_builder",
                "signature": "(self, builder_id)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get_schema",
                "signature": "(self, builder_id)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, spec)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_geom/gen/primitives.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/gen/primitives.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Protocol",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_tm_to_meshdata",
            "signature": "(tm)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_as_3tuple",
            "signature": "(v, default)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_as_centerline_points",
            "signature": "(v)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_linspace01",
            "signature": "(n)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "register_builder",
            "signature": "(*names)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_apply_transform",
            "signature": "(tm, params)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_boolean_engines_available",
            "signature": "()",
            "doc": "Returns a tuple of boolean engines available in trimesh environment.\nTypical names can include: 'manifold', 'blender', 'scad', etc.",
            "decorators": []
          },
          {
            "name": "_boolean_or_fallback",
            "signature": "(tm_a, tm_b, op, *, allow_fallback)",
            "doc": "Robust boolean if possible, otherwise fallback to concatenation.\nFallback is NOT watertight and can self-intersect.",
            "decorators": []
          },
          {
            "name": "_polyline_capsule_tube",
            "signature": "(points, radius, sections)",
            "doc": "Create a \"tube\" along a polyline by concatenating capsules per segment.\nMVP approach that doesn't require CAD/B-Rep.\nFor watertight/production, use a boolean engine to union segments or use a true sweep in CAD.",
            "decorators": []
          },
          {
            "name": "_normalize",
            "signature": "(v, eps)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_rmf_frames",
            "signature": "(centerline)",
            "doc": "Compute rotation-minimizing frames (RMF) along a polyline centerline.\n\nReturns:\n  C: (N,3) points\n  T: (N,3) tangents (unit)\n  N: (N,3) normal-ish (unit)\n  B: (N,3) binormal-ish (unit)",
            "decorators": []
          },
          {
            "name": "build_mesh",
            "signature": "(name, **params)",
            "doc": "General factory:\n  - calls a registered builder -> trimesh.Trimesh\n  - optional transforms: scale / rotate / translate\n  - optional boolean: boolean={op:'cut'|'union'|'intersect', other:{name:'sphere', ...}}\n    -> If no boolean engine exists, it falls back to concatenate (non-watertight).",
            "decorators": []
          },
          {
            "name": "build_primitive",
            "signature": "(name, **params)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_build_box",
            "signature": "(**params)",
            "doc": null,
            "decorators": [
              "register_builder('box', 'cube', 'rect', 'cuboid')"
            ]
          },
          {
            "name": "_build_sphere",
            "signature": "(**params)",
            "doc": null,
            "decorators": [
              "register_builder('sphere')"
            ]
          },
          {
            "name": "_build_cylinder",
            "signature": "(**params)",
            "doc": null,
            "decorators": [
              "register_builder('cylinder')"
            ]
          },
          {
            "name": "_build_plane",
            "signature": "(**params)",
            "doc": null,
            "decorators": [
              "register_builder('plane')"
            ]
          },
          {
            "name": "_build_channel",
            "signature": "(**params)",
            "doc": null,
            "decorators": [
              "register_builder('channel')"
            ]
          },
          {
            "name": "_build_woven_tube",
            "signature": "(**p)",
            "doc": "Woven-like tubular metamaterial (straight axis).\n- Helix + radial waviness (A*cos(k*theta + phase)) to create \"over/under\" feel\n- Optional local thickness field (gaussian around thick_z0)",
            "decorators": [
              "register_builder('woven_tube')"
            ]
          },
          {
            "name": "_build_braid_tube",
            "signature": "(**p)",
            "doc": "Braided tubular material (straight axis):\n- Two sets of helices (right-handed and left-handed) interlaced.\n- Good base for \"high load + high deformation\" when combined with density/thickness fields.",
            "decorators": [
              "register_builder('braid_tube')"
            ]
          },
          {
            "name": "_build_woven_centerline",
            "signature": "(**p)",
            "doc": "Woven mapped on an arbitrary centerline using RMF frames.\n\nInputs:\n  - centerline: array-like (N,3)\n  - n_threads: int\n  - turns: float  (helical turns along the whole centerline)\n  - R: float or callable s->R(s)  OR array-like length M_samples\n  - A, k: radial waviness parameters\n  - wire_r: float or callable (s, thread_idx)->radius\n  - samples: int (resampling along arc-length param)\n  - sections: int (capsule resolution)\n\nThis is the recommended \"next step\" for patient-specific vascular paths\nwithout doing full surface projection.",
            "decorators": [
              "register_builder('woven_centerline')"
            ]
          },
          {
            "name": "_build_braid_centerline",
            "signature": "(**p)",
            "doc": "Braided mapped on an arbitrary centerline using RMF frames.\n\nInputs:\n  - centerline: (N,3)\n  - n_threads: total threads (split half right/half left)\n  - turns: turns along the whole centerline\n  - R: float or callable s->R(s)\n  - wire_r: float or callable (s, thread_idx)->radius\n  - samples, sections",
            "decorators": [
              "register_builder('braid_centerline')"
            ]
          },
          {
            "name": "project_points_to_surface",
            "signature": "(points, surface, *, method)",
            "doc": "Placeholder / hook for future \"fidelity maximum\" mapping:\n  - Given points (N,3), project them onto a patient-specific surface mesh.\n\nThis is intentionally NOT implemented generically here because:\n  - robust projection requires spatial acceleration structures (kdtree/bvh),\n  - careful handling of inside/outside normals,\n  - and often a CAD kernel or dedicated geometry library.\n\nRecommended path:\n  - Use a proper BVH nearest-point query (trimesh has proximity module),\n  - then add constraints (stay within thickness, avoid foldovers),\n  - and finally correct collisions with local thickness/spacing.\n\nRaise by default so you don't mistakenly assume it's working.",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "MeshBuilder",
            "bases": [
              "Protocol"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, **params)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_geom/gen/__init__.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/gen/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "primitives",
            "level": 1,
            "names": [
              {
                "name": "build_primitive",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "cadquery_gen",
            "level": 1,
            "names": [
              {
                "name": "cadquery_available",
                "as": null
              },
              {
                "name": "cadquery_to_trimesh",
                "as": null
              },
              {
                "name": "build_mesh_from_step",
                "as": null
              },
              {
                "name": "build_mesh_from_cadquery_object",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_geom/io/cadquery_bridge.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/io/cadquery_bridge.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "pinneaple_data.physical_sample",
            "level": 0,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "cadquery_solid_to_upd",
            "signature": "(solid, *, tess_linear_deflection, tess_angular_deflection, units, meta)",
            "doc": "Convert a CadQuery solid/workplane to a triangle mesh and wrap as PhysicalSample.",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/io/meshio_bridge.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/io/meshio_bridge.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinneaple_data.physical_sample",
            "level": 0,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "load_meshio",
            "signature": "(path, *, require_triangles)",
            "doc": "Load a mesh file using meshio and return a triangle MeshData.\n\nWorks well for:\n  .vtk, .vtu, .msh, .xdmf, .xmf, ...\n\nNotes:\n  - Many CFD meshes are volumetric (tet/hex). MVP supports only surface triangles.\n  - If the file contains triangles, we extract them.\n  - If it has only quads, we can optionally triangulate in a later MVP.",
            "decorators": []
          },
          {
            "name": "save_meshio",
            "signature": "(mesh, path, *, file_format, point_data, cell_data)",
            "doc": "Save MeshData via meshio.\n\nBy default, writes triangles only.\n\nfile_format examples: \"vtk\", \"vtu\", \"stl\", \"ply\", ...",
            "decorators": []
          },
          {
            "name": "meshio_to_upd",
            "signature": "(path)",
            "doc": "Load mesh + point data from any meshio-supported format (VTK, Exodus, etc.)",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/io/openfoam.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/io/openfoam.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "import",
            "name": "glob",
            "as": null
          },
          {
            "type": "import",
            "name": "re",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "pinneaple_data.physical_sample",
            "level": 0,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_latest_time_dir",
            "signature": "(case_dir)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_read_uniform_field",
            "signature": "(text)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_read_internal_field",
            "signature": "(path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "openfoam_case_to_upd",
            "signature": "(case_dir, *, time, fields)",
            "doc": "Very small but practical OpenFOAM bridge:\n  - reads internalField for requested fields at one time directory\n  - stores as PhysicalSample fields\n\nNotes:\n  - Full OpenFOAM parsing is complex; this MVP is for internalField extraction + provenance.\n  - Geometry/mesh can be added later (polyMesh).",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/io/stl.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/io/stl.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinneaple_geom.io.trimesh_bridge",
            "level": 0,
            "names": [
              {
                "name": "TrimeshBridge",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinneaple_data.physical_sample",
            "level": 0,
            "names": [
              {
                "name": "PhysicalSample",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "load_stl",
            "signature": "(path, *, repair, compute_normals)",
            "doc": "Convenience STL loader (via trimesh) returning MeshData.\n\nSTL is extremely common for geometry-only inputs.",
            "decorators": []
          },
          {
            "name": "stl_to_upd",
            "signature": "(path, *, repair, compute_normals, units)",
            "doc": "Load an STL and package it as a UPD-aligned PhysicalSample.\n\nReturns a PhysicalSample where:\n  - state contains {\"vertices\": Tensor[V,3], \"faces\": Tensor[F,3]}\n  - domain indicates a mesh sample\n  - provenance tracks the source path + optional id",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/io/trimesh_bridge.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/io/trimesh_bridge.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "TrimeshBridge",
            "bases": [],
            "doc": "Adapter between trimesh.Trimesh and Pinneaple MeshData.\n\nResponsibilities:\n  - Load meshes from disk\n  - Repair / clean meshes\n  - Convert to MeshData (internal representation)",
            "class_vars": [],
            "methods": [
              {
                "name": "load",
                "signature": "(self, path, *, repair)",
                "doc": "Load geometry using trimesh and return MeshData.",
                "decorators": []
              },
              {
                "name": "from_trimesh",
                "signature": "(self, tm, *, compute_normals)",
                "doc": "Convert trimesh.Trimesh -> MeshData.",
                "decorators": []
              },
              {
                "name": "_load_trimesh",
                "signature": "(self, path)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_repair_trimesh",
                "signature": "(self, tm)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_geom/io/__init__.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/io/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "cadquery_bridge",
            "level": 1,
            "names": [
              {
                "name": "cadquery_solid_to_upd",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "openfoam",
            "level": 1,
            "names": [
              {
                "name": "openfoam_case_to_upd",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "stl",
            "level": 1,
            "names": [
              {
                "name": "load_stl",
                "as": null
              },
              {
                "name": "stl_to_upd",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "meshio_bridge",
            "level": 1,
            "names": [
              {
                "name": "load_meshio",
                "as": null
              },
              {
                "name": "save_meshio",
                "as": null
              },
              {
                "name": "meshio_to_upd",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "trimesh_bridge",
            "level": 1,
            "names": [
              {
                "name": "TrimeshBridge",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_geom/ops/features.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/ops/features.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "compute_face_normals",
            "signature": "(mesh)",
            "doc": "Compute face normals (M,3).",
            "decorators": []
          },
          {
            "name": "compute_vertex_normals",
            "signature": "(mesh)",
            "doc": "Compute vertex normals by area-weighted face normals.",
            "decorators": []
          },
          {
            "name": "compute_face_areas",
            "signature": "(mesh)",
            "doc": "Compute triangle face areas (M,).",
            "decorators": []
          },
          {
            "name": "compute_curvature_proxy",
            "signature": "(mesh)",
            "doc": "Very lightweight curvature proxy per face.\n\nDefined as variation of normals across neighboring faces.\nMVP proxy: |n - mean(n_neighbors)|.\n\nNote:\n  - This is NOT true curvature.\n  - It's useful as a feature or sampling weight.",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/ops/remesh.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/ops/remesh.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "remesh_surface",
            "signature": "(mesh, *, max_edge_length, target_edge_length)",
            "doc": "Surface remeshing (best-effort).\n\nMVP behavior:\n  - If pymeshlab is available, use isotropic remeshing.\n  - Otherwise, return mesh unchanged.\n\nThis is intentionally conservative to avoid breaking pipelines.",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/ops/repair.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/ops/repair.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "repair_mesh",
            "signature": "(mesh, *, remove_duplicates, remove_degenerate, fix_normals, fill_holes)",
            "doc": "Best-effort mesh repair using trimesh.\n\nReturns a NEW MeshData (does not mutate input).",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/ops/simplify.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/ops/simplify.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_to_trimesh",
            "signature": "(mesh)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_from_trimesh",
            "signature": "(tm)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_open3d_available",
            "signature": "()",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_simplify_open3d",
            "signature": "(mesh, target_faces)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "simplify_mesh",
            "signature": "(mesh, *, target_faces, backend, on_missing)",
            "doc": "Simplify a mesh.\n\nbackend:\n  - \"auto\": try trimesh fast_simplification, else open3d, else fallback\n  - \"trimesh\": only trimesh (requires fast_simplification)\n  - \"open3d\": only open3d\n\non_missing:\n  - \"error\": raise if no backend available\n  - \"return_input\": return the input mesh unchanged",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/ops/__init__.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/ops/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "repair",
            "level": 1,
            "names": [
              {
                "name": "repair_mesh",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "simplify",
            "level": 1,
            "names": [
              {
                "name": "simplify_mesh",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "remesh",
            "level": 1,
            "names": [
              {
                "name": "remesh_surface",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "features",
            "level": 1,
            "names": [
              {
                "name": "compute_face_normals",
                "as": null
              },
              {
                "name": "compute_vertex_normals",
                "as": null
              },
              {
                "name": "compute_face_areas",
                "as": null
              },
              {
                "name": "compute_curvature_proxy",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_geom/sample/barycentric.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/sample/barycentric.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          }
        ],
        "functions": [
          {
            "name": "sample_barycentric_uv",
            "signature": "(n, rng)",
            "doc": "Sample barycentric weights (w0, w1, w2) uniformly over a triangle.\n\nUses the classic trick:\n  u, v ~ U(0,1)\n  su = sqrt(u)\n  w0 = 1 - su\n  w1 = su * (1 - v)\n  w2 = su * v",
            "decorators": []
          },
          {
            "name": "sample_points_on_triangles",
            "signature": "(tri_v0, tri_v1, tri_v2, n, rng)",
            "doc": "Sample n points uniformly on a single triangle defined by (v0,v1,v2).\n\ntri_v*: shape (3,)\nreturns: (n,3)",
            "decorators": []
          },
          {
            "name": "interpolate_on_triangles",
            "signature": "(values_v0, values_v1, values_v2, w0, w1, w2)",
            "doc": "Barycentric interpolation of any per-vertex values.\n\nvalues_v*: shape (n, d) OR (d,) broadcastable\nw*: shape (n,)\nreturns: shape (n, d)",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/sample/grids.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/sample/grids.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          }
        ],
        "functions": [
          {
            "name": "sample_uniform_box",
            "signature": "(bounds_min, bounds_max, n, rng)",
            "doc": "Uniform random samples inside an axis-aligned bounding box.\n\nbounds_min/max: (3,)\nreturns: (n,3)",
            "decorators": []
          },
          {
            "name": "sample_latin_hypercube_box",
            "signature": "(bounds_min, bounds_max, n, rng)",
            "doc": "Latin Hypercube Sampling (LHS) in an axis-aligned box.\nGood for collocation coverage without clustering.\n\nbounds_min/max: (d,) (commonly d=3)\nreturns: (n,d)",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/sample/points.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/sample/points.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "from",
            "module": "pinneaple_geom.core.mesh",
            "level": 0,
            "names": [
              {
                "name": "MeshData",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinneaple_geom.ops.features",
            "level": 0,
            "names": [
              {
                "name": "compute_face_normals",
                "as": null
              },
              {
                "name": "compute_face_areas",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "barycentric",
            "level": 1,
            "names": [
              {
                "name": "sample_barycentric_uv",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_choice_weighted",
            "signature": "(rng, weights, n)",
            "doc": "Weighted random choice over faces.\nweights: (M,) non-negative\nreturns: (n,) indices",
            "decorators": []
          },
          {
            "name": "sample_surface_points",
            "signature": "(mesh, n, *, rng, return_normals, return_face_id)",
            "doc": "Sample n points uniformly over the surface (triangle areas as weights).\n\nReturns:\n  points: (n,3)\n  normals: (n,3) or None\n  face_id: (n,) or None",
            "decorators": []
          },
          {
            "name": "sample_surface_points_weighted",
            "signature": "(mesh, n, *, face_weights, rng, return_normals, return_face_id)",
            "doc": "Sample n points on surface using user-provided per-face weights.\n\nUseful for importance sampling (e.g., high curvature regions).",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_geom/sample/__init__.py": {
      "package": "pinneaple_geom",
      "path": "pinneaple_geom/sample/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "barycentric",
            "level": 1,
            "names": [
              {
                "name": "sample_barycentric_uv",
                "as": null
              },
              {
                "name": "sample_points_on_triangles",
                "as": null
              },
              {
                "name": "interpolate_on_triangles",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "grids",
            "level": 1,
            "names": [
              {
                "name": "sample_uniform_box",
                "as": null
              },
              {
                "name": "sample_latin_hypercube_box",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "points",
            "level": 1,
            "names": [
              {
                "name": "sample_surface_points",
                "as": null
              },
              {
                "name": "sample_surface_points_weighted",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ModelOutput",
            "bases": [],
            "doc": null,
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "BaseModel",
            "bases": [
              "nn.Module"
            ],
            "doc": "Unified base class for all Pinneaple models.",
            "class_vars": [
              "family",
              "name"
            ],
            "methods": [
              {
                "name": "forward",
                "signature": "(self, *args, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/catalog.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/catalog.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "autoencoders.registry",
            "level": 1,
            "names": [
              {
                "name": "AutoencoderCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinns.registry",
            "level": 1,
            "names": [
              {
                "name": "PINNCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "transformers.registry",
            "level": 1,
            "names": [
              {
                "name": "TransformerCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "recurrent.registry",
            "level": 1,
            "names": [
              {
                "name": "RecurrentCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "convolutions.registry",
            "level": 1,
            "names": [
              {
                "name": "ConvolutionCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "neural_operators.registry",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "continuous.registry",
            "level": 1,
            "names": [
              {
                "name": "ContinuousCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "graphnn.registry",
            "level": 1,
            "names": [
              {
                "name": "GraphCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "reservoir_computing.registry",
            "level": 1,
            "names": [
              {
                "name": "ReservoirCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "classical_ts.registry",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "rom.registry",
            "level": 1,
            "names": [
              {
                "name": "ROMCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "physics_aware.registry",
            "level": 1,
            "names": [
              {
                "name": "PhysicsAwareCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ModelCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "autoencoders",
              "classical_ts",
              "continuous",
              "convolutions",
              "graphnn",
              "neural_operators",
              "physics_aware",
              "pinns",
              "recurrent",
              "reservoir_computing",
              "rom",
              "transformers"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_models/register_all.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/register_all.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_all",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_models/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "BaseModel",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ModelSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "cls",
              "description",
              "family",
              "name",
              "tags"
            ],
            "methods": []
          },
          {
            "name": "ModelRegistry",
            "bases": [],
            "doc": "Central registry for all Pinneaple models.",
            "class_vars": [
              "_REGISTRY"
            ],
            "methods": [
              {
                "name": "register",
                "signature": "(cls, *, name, family, description, tags)",
                "doc": "Decorator to register a model class.",
                "decorators": [
                  "classmethod"
                ]
              },
              {
                "name": "list",
                "signature": "(cls, family)",
                "doc": null,
                "decorators": [
                  "classmethod"
                ]
              },
              {
                "name": "families",
                "signature": "(cls)",
                "doc": null,
                "decorators": [
                  "classmethod"
                ]
              },
              {
                "name": "spec",
                "signature": "(cls, name)",
                "doc": null,
                "decorators": [
                  "classmethod"
                ]
              },
              {
                "name": "build",
                "signature": "(cls, name, **kwargs)",
                "doc": null,
                "decorators": [
                  "classmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/_registry_bridge.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/_registry_bridge.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "ModelRegistry",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "BaseModel",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_family_registry",
            "signature": "(local_registry, *, family, name_mapper, description_getter, tags_getter, skip_aliases)",
            "doc": "Bridge a family-local _REGISTRY into the global ModelRegistry.\n\nlocal_registry: dict key->cls (your existing pattern)\nfamily: global family name (\"transformers\", \"pinns\", ...)\nname_mapper: maps (key, cls) -> global model name\nskip_aliases: if True, avoids registering multiple keys pointing to the same class",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_models/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "ModelRegistry",
                "as": null
              },
              {
                "name": "ModelSpec",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/autoencoders/ae_2d.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/ae_2d.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "import",
            "name": "torch.nn.functional",
            "as": "F"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "AEBase",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Autoencoder2D",
            "bases": [
              "AEBase"
            ],
            "doc": "Conv2D autoencoder for images / 2D fields.\n\nArgs:\n  in_channels: channels in input (e.g. 1 for scalar field)\n  latent_dim: latent vector dim\n  img_size: (H,W) required to build final linear layers\n  base_channels: width multiplier\n\nNotes:\n  - Robust output sizing: decoder output is resized to (H, W) via interpolate if needed.\n  - Optional output activation: set via output_activation.\n  - Safer reshape instead of view.\n  - Optional normalization (GroupNorm by default) between conv and activation.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_channels, latent_dim, img_size, base_channels, norm, gn_groups, output_activation, resize_mode, align_corners)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "encode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/autoencoders/ae_rom_hybrid.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/ae_rom_hybrid.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "AEBase",
                "as": null
              },
              {
                "name": "AEOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dense_ae",
            "level": 1,
            "names": [
              {
                "name": "_mlp",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_as_dt",
            "signature": "(dt, batch_size, device, dtype)",
            "doc": "Normaliza dt para shape (B,).\nAceita:\n  - float\n  - tensor escalar\n  - tensor (B,)",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "AEROMHybrid",
            "bases": [
              "AEBase"
            ],
            "doc": "AE-ROM Hybrid (Koopman/latent linear dynamics) com:\n  - AE denso (encoder/decoder)\n  - Dinmica contnua linear no latente: dz/dt = K z + c\n  - Passo discreto via Euler: z_next_pred = z + dt*(K z + c)\n  - Loss de previso em x (decode do z_next_pred)\n  - Rollout multi-step (latente e x)\n  - Regularizao de estabilidade (contratividade via parte simtrica de K)\n  - Atualizao de K,c por Least Squares (ridge)\n\nforward suporta:\n  - forward(x)\n  - forward(x, x_next=..., dt=...) adiciona losses 1-step\n  - forward(x, x_seq=..., dt_seq=...) adiciona rollout multi-step\n\nx_seq: Tensor shape (B, K, input_dim) ou (B, K, ...) que ser achatado para (B, K, input_dim)\ndt_seq: float / tensor escalar / tensor (B,) / tensor (B, K)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, latent_dim, hidden, activation, rom_weight, pred_weight, rollout_latent_weight, rollout_x_weight, stability_weight, stability_margin, ls_ridge, ls_update_in_forward, detach_ls_targets)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "encode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "latent_step",
                "signature": "(self, z, dt)",
                "doc": "Um passo Euler no latente:\n  z_next = z + dt*(K z + c)",
                "decorators": []
              },
              {
                "name": "fit_rom_ls",
                "signature": "(self, z, z_next, dt, ridge)",
                "doc": "Ajusta K,c por least squares (ridge) no modelo:\n  (z_next - z)/dt = z @ K^T + c\n\nz, z_next: (B,d)\ndt: float | escalar | (B,)",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "stability_penalty",
                "signature": "(self)",
                "doc": "Penaliza instabilidade incentivando contrao na dinmica contnua.\n\nUsamos a parte simtrica:\n  S = 0.5*(K + K^T)\nPara um sistema linear contnuo, exigir S negativo (autovalor mximo <= -margin)\najuda a evitar crescimento de energia.",
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, x_next, dt, x_seq, dt_seq)",
                "doc": "x: (B, ...) -> recon\nx_next + dt -> 1-step losses\nx_seq + dt_seq -> rollout multi-step (x_seq shape (B,K,...) e dt_seq float | (B,) | (B,K))",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/autoencoders/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "AEOutput",
            "bases": [],
            "doc": "Standardized output for all AEs.",
            "class_vars": [
              "extras",
              "losses",
              "x_hat",
              "z"
            ],
            "methods": []
          },
          {
            "name": "AEBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base class for all autoencoders in Pinneaple.\n\nContract:\n  - encode(x) -> z\n  - decode(z) -> x_hat\n  - forward(x) -> AEOutput\n  - loss(output, x) -> dict of losses (recon + model-specific)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "encode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "loss_from_parts",
                "signature": "(self, *, x_hat, z, x)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/autoencoders/dense_ae.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/dense_ae.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "AEBase",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_mlp",
            "signature": "(dims, act, last_act)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "DenseAutoencoder",
            "bases": [
              "AEBase"
            ],
            "doc": "Plain MLP autoencoder for vector inputs.\n\nArgs:\n  input_dim: flattened input dimension\n  latent_dim: bottleneck dim\n  hidden: list of hidden widths for encoder (decoder mirrors)\n  activation: \"tanh\"|\"relu\"|\"gelu\"",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, latent_dim, hidden, activation)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "encode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/autoencoders/kae.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/kae.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "AEBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dense_ae",
            "level": 1,
            "names": [
              {
                "name": "_mlp",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_pairwise_sq_dists",
            "signature": "(x, y)",
            "doc": "(n,d), (m,d) -> (n,m) squared Euclidean distances\nUses a stable algebraic form (no cdist dependency).",
            "decorators": []
          },
          {
            "name": "_rbf_kernel_from_dist2",
            "signature": "(dist2, sigma)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_median_heuristic_sigma",
            "signature": "(z)",
            "doc": "Median heuristic for RBF bandwidth on z.\nReturns a python float > 0 (with a small floor for safety).",
            "decorators": []
          },
          {
            "name": "_mmd_rbf_unbiased",
            "signature": "(z, z_prior, sigmas)",
            "doc": "Unbiased MMD^2 estimate with RBF kernels:\n  MMD^2 = E[k(x,x')] + E[k(y,y')] - 2 E[k(x,y)]\nwhere expectations are over distinct pairs (i != j).\nSupports multi-kernel by summing kernels over sigmas.",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "KAEAutoencoder",
            "bases": [
              "AEBase"
            ],
            "doc": "Practical MMD-WAE style Autoencoder:\n  - Dense AE\n  - MMD penalty on latent space to match a simple prior.\n\nBackward-compatible behavior:\n  - Keeps the same constructor args and loss dict keys.\n  - Adds optional multi-kernel support via mmd_sigmas (optional).\n  - If mmd_sigma <= 0, uses median heuristic per-batch.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, latent_dim, hidden, activation, mmd_weight, mmd_sigma, prior, mmd_sigmas)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "encode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_get_sigmas",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "loss_from_parts",
                "signature": "(self, *, x_hat, z, x)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/autoencoders/koopman_pi_ae.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/koopman_pi_ae.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "AEBase",
                "as": null
              },
              {
                "name": "AEOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dense_ae",
            "level": 1,
            "names": [
              {
                "name": "_mlp",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PhysicsInformedKoopmanAutoencoder",
            "bases": [
              "AEBase"
            ],
            "doc": "Koopman AE (prtico / literature-grade):\n  - Dense AE\n  - Operador linear treinvel no latente (K, opcionalmente com bias b)\n  - Suporte explcito a dt via gerador contnuo A (K_eff = expm(A*dt)) se desejado\n  - Loss no latente: ||z_next - K_eff z||^2\n  - Loss de previso no espao original: ||x_next - D(K_eff E(x))||^2\n  - Multi-step / rollout loss se x_next vier como sequncia (B,H,dim)\n  - Regularizao de estabilidade (penaliza sigma_max(K_eff) > 1)\n  - Opo de atualizar K por least squares (EDMD-like) quando x_next  fornecido\n\nforward:\n  - forward(x) -> recon apenas\n  - forward(x, x_next=...) -> adiciona losses dinmicas\n    * x_next pode ser (B, D) ou (B, H, D)\n\nArgs:\n  input_dim, latent_dim, hidden\n  koopman_weight: peso da loss no latente (1-step)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, latent_dim, hidden, activation, koopman_weight, *, pred_weight, rollout_weight, stability_weight, use_affine, use_generator_A, ls_update, ls_ridge, power_iters)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "encode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_as_dt",
                "signature": "(self, dt, *, device, dtype, steps, batch)",
                "doc": "Retorna dt como tensor broadcastvel para (B, steps, 1, 1) se necessrio.\nAceita:\n  - None -> 1.0\n  - float\n  - tensor escalar\n  - (steps,)\n  - (B, steps)",
                "decorators": []
              },
              {
                "name": "_effective_operator",
                "signature": "(self, dt_scalar)",
                "doc": "Retorna K_eff (latent_dim x latent_dim) para um dt escalar (tensor 0-d).\n- Se use_generator_A: expm(A*dt)\n- Caso contrrio: K (assumindo dt fixo no dataset)",
                "decorators": []
              },
              {
                "name": "_apply_K",
                "signature": "(self, z, K_eff)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_least_squares_update_K",
                "signature": "(self, z, z_next)",
                "doc": "Atualiza self.K (e opcionalmente b) via mnimos quadrados (ridge).\nResolve: z_next  z @ K^T + b\nRetorna K_ls (para logging).",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "_sigma_max_penalty",
                "signature": "(self, K_eff)",
                "doc": "Penaliza sigma_max(K_eff) > 1 (estimado por power iteration em K^T K).",
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, x_next, dt)",
                "doc": "x_next:\n  - None: s recon\n  - (B, D): 1-step\n  - (B, H, D): rollout multi-step supervision\ndt:\n  - None -> 1.0\n  - float/tensor escalar -> mesmo dt para todos\n  - (H,) ou (B,H) se x_next for sequncia",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/autoencoders/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "AEBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dense_ae",
            "level": 1,
            "names": [
              {
                "name": "DenseAutoencoder",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "ae_2d",
            "level": 1,
            "names": [
              {
                "name": "Autoencoder2D",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "vae",
            "level": 1,
            "names": [
              {
                "name": "VariationalAutoencoder",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "kae",
            "level": 1,
            "names": [
              {
                "name": "KAEAutoencoder",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "koopman_pi_ae",
            "level": 1,
            "names": [
              {
                "name": "PhysicsInformedKoopmanAutoencoder",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "ae_rom_hybrid",
            "level": 1,
            "names": [
              {
                "name": "AEROMHybrid",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "AutoencoderCatalog",
            "bases": [],
            "doc": "Group entrypoint:\n  cat = AutoencoderCatalog()\n  model = cat.build(\"vae\", input_dim=..., latent_dim=...)",
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/autoencoders/vae.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/vae.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "AEBase",
                "as": null
              },
              {
                "name": "AEOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dense_ae",
            "level": 1,
            "names": [
              {
                "name": "_mlp",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "VariationalAutoencoder",
            "bases": [
              "AEBase"
            ],
            "doc": "MLP VAE for vector inputs.\n\nArgs:\n  input_dim\n  latent_dim\n  hidden\n  beta: weight on KL term (beta-VAE)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, latent_dim, hidden, beta, activation, clamp_logvar, recon_reduction)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "encode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_reparam",
                "signature": "(self, mu, logvar)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "loss_from_parts",
                "signature": "(self, *, x_hat, z, x, mu, logvar)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/autoencoders/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/autoencoders/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "AutoencoderCatalog",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "AEBase",
                "as": null
              },
              {
                "name": "AEOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/classical_ts/arima.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/arima.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              },
              {
                "name": "ClassicalTSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ARIMA",
            "bases": [
              "ClassicalTSBase"
            ],
            "doc": "ARIMA(p,d,q) MVP without external deps:\n\n- Supports differencing order d\n- Supports AR(p) with ridge regression\n- q (MA) is NOT implemented in this MVP (kept for API compatibility)\n\nUse:\n  fit(x) where x: (B,T,dim) or (B,T,1)\n  forecast(x_hist, steps)\n\nNotes:\n  - For d>0, forward() returns predictions in ORIGINAL space (aligned), and also\n    provides differenced predictions in extras[\"y_differenced\"].\n  - This is effectively an AR(p) on ^d(x), i.e., ARI(p,d) since MA(q) is not implemented.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, dim, p, d, q, l2, use_bias)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_difference",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_last_diff_states",
                "signature": "(self, x_hist)",
                "doc": "Builds integration state for undifferencing up to order d-1.\n\nReturns:\n  states = [x_T, x_T, ^2 x_T, ..., ^{d-1} x_T]  each (B,D)\nwhere T is the last time index in x_hist.\n\nFor d=0: returns [].",
                "decorators": []
              },
              {
                "name": "_undifference_forecast",
                "signature": "(self, x_hist, dx_fore)",
                "doc": "Reconstruct forecast in original space given ^d-forecasts.\n\nArgs:\n  x_hist: (B,T,D) original history\n  dx_fore: (B,steps,D) forecasts in differenced space of order d (i.e., ^d x)\n\nReturns:\n  y: (B,steps,D) forecast in original space",
                "decorators": []
              },
              {
                "name": "_ridge_solve",
                "signature": "(X, Y, l2)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "_make_design",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_targets",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, x)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forecast",
                "signature": "(self, x_hist, steps)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": "One-step-ahead predictions along the provided sequence.\n\nReturns predictions in ORIGINAL space by default.\nAlso exposes differenced predictions in extras[\"y_differenced\"].",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ClassicalTSOutput",
            "bases": [],
            "doc": "Output for classical time-series / filtering models.\n\ny:\n  - forecasts or filtered states:\n    (B,T,dim) or (B,H,dim) depending on method\nextras:\n  - optional covariances, gains, etc.",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "ClassicalTSBase",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/ekf.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/ekf.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              },
              {
                "name": "ClassicalTSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ExtendedKalmanFilter",
            "bases": [
              "ClassicalTSBase"
            ],
            "doc": "EKF (robust MVP):\n  x_t = f(x_{t-1}, u_t) + w\n  y_t = h(x_t) + v\n\nUser provides:\n  f: (x,u)->x\n  h: x->y\n  F_jac: Jacobian of f wrt x, shape (B,n,n)\n  H_jac: Jacobian of h wrt x, shape (B,m,n)\n\nChanges vs previous:\n  (1) F_jac evaluated at x_prev (pre-propagation) to match standard discrete EKF linearization\n  (2) Joseph-form covariance update for numerical stability / PSD preservation\n  (3) Replace inv(S) with solve(S, )",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, f, h, Q, R, F_jac, H_jac)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, y, *, u, x0, P0, return_gain)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/enkf.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/enkf.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              },
              {
                "name": "ClassicalTSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "EnsembleKalmanFilter",
            "bases": [
              "ClassicalTSBase"
            ],
            "doc": "Ensemble Kalman Filter (EnKF) MVP:\n\n  - Maintain ensemble of states X^k\n  - Predict each ensemble through f\n  - Update using sample covariances\n\nUser provides:\n  f(x,u)->x  (vectorized over ensemble)\n  h(x)->y",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, f, h, Q, R, *, ensemble_size)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, y, *, u, x0, return_ensembles)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/kalman.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/kalman.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              },
              {
                "name": "ClassicalTSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "KalmanFilter",
            "bases": [
              "ClassicalTSBase"
            ],
            "doc": "Linear Kalman Filter (batch, robust):\n\n  x_{t} = A x_{t-1} + B u_t + w,  w ~ N(0,Q)\n  y_{t} = H x_{t}   + v,          v ~ N(0,R)\n\nShapes:\n  A: (n,n)\n  H: (m,n)\n  Q: (n,n)\n  R: (m,m)\n  B: (n,du) optional",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, A, H, Q, R, *, B)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, y, *, u, x0, P0, return_gain)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "var",
            "level": 1,
            "names": [
              {
                "name": "VAR",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "arima",
            "level": 1,
            "names": [
              {
                "name": "ARIMA",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "kalman",
            "level": 1,
            "names": [
              {
                "name": "KalmanFilter",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "ekf",
            "level": 1,
            "names": [
              {
                "name": "ExtendedKalmanFilter",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "ukf",
            "level": 1,
            "names": [
              {
                "name": "UnscentedKalmanFilter",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "enkf",
            "level": 1,
            "names": [
              {
                "name": "EnsembleKalmanFilter",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "tcn",
            "level": 1,
            "names": [
              {
                "name": "TCN",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ClassicalTSCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/tcn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/tcn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "import",
            "name": "torch.nn.functional",
            "as": "F"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              },
              {
                "name": "ClassicalTSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_Chomp1d",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, chomp)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "_TCNBlock",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_ch, out_ch, kernel, dilation, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "TCN",
            "bases": [
              "ClassicalTSBase"
            ],
            "doc": "TCN for sequence-to-sequence regression.\n\nInput:\n  x: (B,T,in_dim)\nOutput:\n  y: (B,T,out_dim)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, *, channels, kernel, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/ukf.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/ukf.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              },
              {
                "name": "ClassicalTSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "UnscentedKalmanFilter",
            "bases": [
              "ClassicalTSBase"
            ],
            "doc": "UKF (sigma-point filter), batch-friendly.\n\nUser provides:\n  f(x,u)->x\n  h(x)->y\n\nParameters:\n  alpha, beta, kappa control sigma points.\n\nNotes (robustness vs. nave UKF):\n  - avoids explicit matrix inverse (uses solve)\n  - enforces symmetry and adds jitter to keep covariances SPD\n  - stable Cholesky with retry",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, f, h, Q, R, *, alpha, beta, kappa, jitter, jitter_growth, max_cholesky_tries)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_symmetrize",
                "signature": "(A)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "_stable_cholesky",
                "signature": "(self, A)",
                "doc": "A: (B,n,n) expected symmetric PSD/SPD.\nReturns L such that L L^T = A (+ jitter I if needed)",
                "decorators": []
              },
              {
                "name": "_sigma_points",
                "signature": "(self, x, P)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, y, *, u, x0, P0, return_gain)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/var.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/var.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              },
              {
                "name": "ClassicalTSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "VAR",
            "bases": [
              "ClassicalTSBase"
            ],
            "doc": "VAR(p) with ridge regression (closed form).\n\nx_t = c + sum_{k=1..p} A_k x_{t-k} + eps\n\nFit uses batch-aggregated least squares over all sequences.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, dim, p, l2, use_bias)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_make_design",
                "signature": "(self, x)",
                "doc": "Vectorized design matrix builder.\n\nx: (B, T, D)\nreturns X: (B*(T-p), D*p (+1))",
                "decorators": []
              },
              {
                "name": "_targets",
                "signature": "(self, x)",
                "doc": "Vectorized targets builder.\n\nx: (B, T, D)\nreturns Y: (B*(T-p), D)",
                "decorators": []
              },
              {
                "name": "_ridge_solve",
                "signature": "(X, Y, l2)",
                "doc": "Ridge regression solve using a more numerically stable method than normal equations solve.\nUses Cholesky on (X^T X + l2 I), which is SPD for l2 > 0.",
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "fit",
                "signature": "(self, x)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forecast",
                "signature": "(self, x_hist, steps)",
                "doc": "x_hist: (B, T, D) with T >= p\nreturns: (B, steps, D)",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/classical_ts/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/classical_ts/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSBase",
                "as": null
              },
              {
                "name": "ClassicalTSOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "ClassicalTSCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/continuous/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ContOutput",
            "bases": [],
            "doc": "Standard output for continuous-time / probabilistic dynamics models.\n\ny:\n  - forecasts: (B, H, out_dim) OR trajectories (B, T, out_dim)\ndist (optional):\n  - if probabilistic, store params in extras[\"dist\"]",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "ContinuousModelBase",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "gaussian_nll",
                "signature": "(mu, logvar, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/bayesian_rnn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/bayesian_rnn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "LockedDropout",
            "bases": [
              "nn.Module"
            ],
            "doc": "Locked (aka variational) dropout for sequences:\nuses the same dropout mask across the time dimension T.\n\nInput:  (B, T, D)\nOutput: (B, T, D)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, p)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "BayesianRNN",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "Bayesian RNN (MVP via MC Dropout / variational dropout approximation).\n\nImprovements vs original:\n  - LockedDropout for input/head to better match \"variational dropout in RNNs\"\n    (same mask across time).\n  - MC inference kept separate and safe: forward() remains grad-friendly.\n  - Loss zeros created with x.new_zeros(()) to match dtype/device.\n  - Optional return_samples in forward if you want (still default off).\n\nOutput:\n  y: (B,T,out_dim)\n  extras (MC):\n    - \"logvar\": predictive log-variance (B,T,out_dim) from MC samples\n    - \"samples\": (S,B,T,out_dim) if requested",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, out_dim, hidden_dim, num_layers, dropout, cell, min_logvar, max_logvar, *, locked_input_dropout, locked_head_dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_single_pass",
                "signature": "(self, x)",
                "doc": "One stochastic pass (stochastic if model is in train() and dropout p>0).",
                "decorators": []
              },
              {
                "name": "_mc_forward",
                "signature": "(self, x, *, mc_samples, return_samples)",
                "doc": "MC forward helper (no mode restore here; caller manages train/eval state).",
                "decorators": []
              },
              {
                "name": "predict_mc",
                "signature": "(self, x, *, mc_samples, return_samples)",
                "doc": "Inference-time MC dropout:\n  - forces train(True) to keep dropout ON\n  - returns mean and log-variance",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss, mc_samples, return_samples)",
                "doc": "Normal forward:\n  - if mc_samples == 0: single pass, optionally computes MSE loss\n  - if mc_samples  > 0: MC forward (keeps current mode; if you want dropout,\n    call model.train(True) before calling forward)",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/deep_state_space.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/deep_state_space.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "import",
            "name": "torch.nn.functional",
            "as": "F"
          }
        ],
        "functions": [
          {
            "name": "_mlp",
            "signature": "(in_dim, hidden, out_dim, depth)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "gaussian_nll_diag",
            "signature": "(mu, logvar, y)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "kl_diag_gaussians",
            "signature": "(mu_q, logvar_q, mu_p, logvar_p)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ContOutput",
            "bases": [],
            "doc": null,
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "DeepStateSpaceModel",
            "bases": [
              "nn.Module"
            ],
            "doc": "Variational Deep State Space Model (DSSM / deep SSM) - MVP (filtering):\n\nPrior/transition:    p(z_t | z_{t-1}, x_t) = N(mu_p, diag(exp(logvar_p)))\nInference posterior: q(z_t | z_{t-1}, x_t, y_t) = N(mu_q, diag(exp(logvar_q)))\nEmission:            p(y_t | z_t) = N(mu_y, diag(exp(logvar_y)))\n\nInputs:\n  x:      (B, T, input_dim)\n  y_true: (B, T, out_dim)  (needed for training / ELBO)\n\nOutput:\n  y_hat = mu_y: (B, T, out_dim)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, out_dim, latent_dim, hidden_dim, mlp_depth, min_logvar, max_logvar, beta_kl)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_clamp_logvar",
                "signature": "(self, logvar)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_reparam",
                "signature": "(self, mu, logvar)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss, sample)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/hamiltonian.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/hamiltonian.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "HamiltonianNeuralNetwork",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "HNN MVP:\n  - Learn Hamiltonian H(q,p)\n  - Dynamics: dq/dt = dH/dp, dp/dt = -dH/dq",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, dim_q, hidden, num_layers)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, z, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/latent_ode.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/latent_ode.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "import",
            "name": "torch.nn.functional",
            "as": "F"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "neural_ode",
            "level": 1,
            "names": [
              {
                "name": "NeuralODE",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_GRUODECell",
            "bases": [
              "nn.Module"
            ],
            "doc": "Minimal GRU-ODE-style encoder:\n  - Between observations: evolve hidden state h(t) with ODE dh/dt = f(h, t)\n  - At observation times: apply GRU update with x_t\n\nThis is a simplified, literature-aligned \"GRU-ODE\" recognition model.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, hidden, ode_hidden)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "f",
                "signature": "(self, h, t)",
                "doc": "h: (B,H)\nt: scalar tensor or (B,) -> we broadcast to (B,1)",
                "decorators": []
              }
            ]
          },
          {
            "name": "_GRUODEEncoder",
            "bases": [
              "nn.Module"
            ],
            "doc": "Recognition model that encodes an irregularly-sampled sequence (x, t)\ninto a final hidden state, then outputs (mu, logvar) for z0.\n\nInputs:\n  x: (B,T,D)\n  t: (T,) increasing (can be irregular)\n\nNOTE:\n  - Handles irregular times via adaptive ODE steps between t[i-1] and t[i].\n  - Uses a GRUCell update at each observation.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, obs_dim, hidden, latent_dim, method)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, t)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "LatentODE",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "Latent ODE (improved, literature-aligned):\n  - Encoder: GRU-ODE recognition model (handles irregular t)\n  - Latent dynamics: NeuralODE with adaptive solver (default dopri5)\n  - Decoder: Gaussian likelihood (mu_x, log_sigma_x) -> NLL",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, obs_dim, latent_dim, hidden, *, ode_method, enc_method, min_log_sigma, max_log_sigma)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_reparam",
                "signature": "(self, mu, logvar)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_gaussian_nll",
                "signature": "(self, mu_x, log_sigma_x, y)",
                "doc": "Elementwise Gaussian NLL, averaged over batch/time/dim.\nNLL = 0.5*((y-mu)^2 / sigma^2 + 2*log(sigma) + log(2*pi))",
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, t, *, y_true, beta_kl, return_loss)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forecast",
                "signature": "(self, x, t_obs, t_new)",
                "doc": "Encode using observed (x, t_obs) then decode on t_new.\nx:     (B,T_obs,obs_dim)\nt_obs: (T_obs,)\nt_new: (T_new,)\nreturns: ContOutput with y shape (B,T_new,obs_dim)",
                "decorators": [
                  "torch.no_grad()"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/neural_cde.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/neural_cde.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "NeuralCDE",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "Neural CDE (literature-style MVP, no torchcde):\n\nCanonical form:\n    dh_t = F(h_t, t) dX_t\nwhere X_t is the control path. To include drift, we *augment the control*\nwith time as an extra channel:\n    X_t = [t, x_t]  ->  dX = [dt, dx]\n\nWith piecewise-linear interpolation of X and Euler discretization:\n    h_{i+1} = h_i + (F(h_i, t_i) @ dX_i)\n\nInputs:\n  x: (B, T, input_dim) control observations\n  t: (T,) strictly increasing\nOutput:\n  y_hat: (B, T, out_dim) at same timestamps",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, hidden_dim, out_dim, *, f_hidden, g_hidden, num_layers, activation, solver, check_strict_t)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_Ft",
                "signature": "(self, h, t)",
                "doc": "Returns F(h,t) reshaped as (B, H, D+1).",
                "decorators": []
              },
              {
                "name": "_assert_strictly_increasing",
                "signature": "(t)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, t, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/neural_gp.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/neural_gp.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_RandomFourierFeatures",
            "bases": [
              "nn.Module"
            ],
            "doc": "RBF kernel approximation with random Fourier features:\n  k(x,x') ~ phi(x)^T phi(x')\n\nphi(x) = sqrt(2/m) * cos(Wx + b), W ~ N(0, 1/l^2), b ~ U(0,2pi)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, num_features, lengthscale, freeze)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "NeuralGaussianProcess",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "Neural Gaussian Process (RFF + Bayesian Linear head):\n\n- Feature extractor (MLP) -> embedding\n- Random Fourier Features (RBF approx) on embedding\n- Bayesian Linear Regression head => GP-consistent predictive mean/variance\n  (for the GP induced by the RFF kernel approximation)\n\nConditioning:\n  call .condition(x_train, y_train) to compute posterior over head weights.\n\nOutput:\n  mu: (..., out_dim)\n  extras[\"logvar\"]: (..., out_dim)  (posterior predictive variance)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, *, embed_dim, mlp_hidden, mlp_layers, rff_features, rff_lengthscale, freeze_rff, noise_mode, fixed_noise, min_logvar, max_logvar, alpha, jitter)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_flatten",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_noise_var",
                "signature": "(self, ref)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "reset_posterior",
                "signature": "(self)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "condition",
                "signature": "(self, x_train, y_train, *, alpha, noise_var)",
                "doc": "Computes posterior for Bayesian linear head given training data.\nThis is the GP-consistent step (for the GP induced by RFF features).\n\nPosterior:\n  A = alpha I + (1/sigma^2) Phi^T Phi\n  M = (1/sigma^2) A^{-1} Phi^T Y",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "_predict_posterior",
                "signature": "(self, Phi, sigma2)",
                "doc": "Phi: (N, m)\nreturns:\n  mu: (N, out_dim)\n  var: (N, 1)  (same for all outputs under independent heads with same prior/noise)",
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss, use_nll, condition_on_batch)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/neural_ode.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/neural_ode.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_rk4_step",
            "signature": "(f, t, y, dt)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "NeuralODE",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "Neural ODE MVP:\n  dy/dt = f(t, y) where f is a neural net.\n  Integrate over time grid with Euler or RK4.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, state_dim, hidden, num_layers, method)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "dynamics",
                "signature": "(self, t, y)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, y0, t, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/neural_sde.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/neural_sde.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "import",
            "name": "torch.nn.functional",
            "as": "F"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "NeuralSDE",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "Neural SDE (EulerMaruyama) for *solving* problems via simulation:\n\n    dY = f(t, y) dt + G(t, y) dW\n\nImprovements vs MVP:\n  - diag diffusion: sigma = softplus(raw) + eps (more stable than exp(clamp))\n  - full diffusion: parameterize as lower-triangular Cholesky factor L (PSD covariance)\n  - optional multi-path Monte Carlo and antithetic sampling for variance reduction\n  - monotonicity check for t without dt.item() inside the loop\n\nInputs:\n  y0: (B, D)\n  t:  (T,) strictly increasing\nOutputs:\n  y_path: (B, T, D) if n_paths=1\n          (B, K, T, D) if n_paths=K>1 and keep_paths=True\n          (B, T, D) mean over paths if n_paths>1 and keep_paths=False",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, state_dim, *, hidden, num_layers, diffusion, activation, sigma_eps, sigma_max, chol_diag_eps, n_paths, antithetic, keep_paths)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_cat",
                "signature": "(self, t, y)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "drift",
                "signature": "(self, t, y)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_sigma_diag",
                "signature": "(self, t, y)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_chol_full",
                "signature": "(self, t, y)",
                "doc": "Build lower-triangular Cholesky factor L: (..., D, D),\nwith positive diagonal via softplus + eps.",
                "decorators": []
              },
              {
                "name": "_effective_paths",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, y0, t, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/ode_rnn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/ode_rnn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "neural_ode",
            "level": 1,
            "names": [
              {
                "name": "NeuralODE",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ODERNN",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "ODE-RNN MVP:\n  - Integrate hidden state with Neural ODE between observation times\n  - Update with GRUCell when observation arrives",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, input_dim, hidden_dim)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, t, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "neural_ode",
            "level": 1,
            "names": [
              {
                "name": "NeuralODE",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "ode_rnn",
            "level": 1,
            "names": [
              {
                "name": "ODERNN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "latent_ode",
            "level": 1,
            "names": [
              {
                "name": "LatentODE",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "neural_cde",
            "level": 1,
            "names": [
              {
                "name": "NeuralCDE",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "neural_sde",
            "level": 1,
            "names": [
              {
                "name": "NeuralSDE",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "hamiltonian",
            "level": 1,
            "names": [
              {
                "name": "HamiltonianNeuralNetwork",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "symplectic_ode",
            "level": 1,
            "names": [
              {
                "name": "SymplecticODENet",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "symplectic_rnn",
            "level": 1,
            "names": [
              {
                "name": "SymplecticRNN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "bayesian_rnn",
            "level": 1,
            "names": [
              {
                "name": "BayesianRNN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "deep_state_space",
            "level": 1,
            "names": [
              {
                "name": "DeepStateSpaceModel",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "neural_gp",
            "level": 1,
            "names": [
              {
                "name": "NeuralGaussianProcess",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ContinuousCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/symplectic_ode.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/symplectic_ode.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "SymplecticODENet",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "Symplectic ODE-Net:\n\n  - Learns separable Hamiltonian: H(q,p)=T(p)+V(q)\n  - Field is Hamiltonian by construction\n  - Provides symplectic integrator (StormerVerlet) for rollout",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, dim_q, hidden)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "hamiltonian",
                "signature": "(self, q, p)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "vector_field",
                "signature": "(self, z)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, z, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "symplectic_step",
                "signature": "(self, z, dt)",
                "doc": "One StormerVerlet step.\nz: (N, 2*dim_q)\ndt: timestep",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "rollout",
                "signature": "(self, z0, dt, steps)",
                "doc": "Perform multiple symplectic steps.\nReturns trajectory tensor of shape (steps+1, N, 2*dim_q)",
                "decorators": [
                  "torch.no_grad()"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/symplectic_rnn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/symplectic_rnn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "SymplecticRNN",
            "bases": [
              "ContinuousModelBase"
            ],
            "doc": "Symplectic RNN (MVP, leapfrog-style update):\n\nState z = [q, p], dim_q = dim_p.\nWe learn a separable Hamiltonian H(q,p) = T(p) + V(q).\n\nDiscrete symplectic update (leapfrog / StrmerVerlet):\n  p_{n+1/2} = p_n - (dt/2) * dV/dq(q_n)\n  q_{n+1}   = q_n + dt * dT/dp(p_{n+1/2})\n  p_{n+1}   = p_{n+1/2} - (dt/2) * dV/dq(q_{n+1})\n\nInputs:\n  z0: (B, 2*dim_q)\n  t:  (T,) increasing  (dt can vary)\nOutput:\n  z_path: (B, T, 2*dim_q)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, dim_q, *, hidden, num_layers, activation)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "dTdp",
                "signature": "(self, p)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "dVdq",
                "signature": "(self, q)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, z0, t, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/continuous/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/continuous/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ContinuousModelBase",
                "as": null
              },
              {
                "name": "ContOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "ContinuousCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/convolutions/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/convolutions/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ConvOutput",
            "bases": [],
            "doc": "Standard output for convolutional models in Pinneaple.",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "ConvModelBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base class for convolution models.\n\nMVP conventions:\n  - Conv1D expects x: (B, C_in, L)\n  - Conv2D expects x: (B, C_in, H, W)\n  - Conv3D expects x: (B, C_in, D, H, W)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/convolutions/conv1d.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/convolutions/conv1d.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ConvModelBase",
                "as": null
              },
              {
                "name": "ConvOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Conv1DModel",
            "bases": [
              "ConvModelBase"
            ],
            "doc": "Conv1D regression model.\n\nInput:\n  x: (B, C_in, L)\nOutput:\n  y: (B, C_out, L) by default (same-length)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_channels, out_channels, hidden_channels, num_blocks, kernel_size, dropout, residual)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/convolutions/conv2d.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/convolutions/conv2d.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ConvModelBase",
                "as": null
              },
              {
                "name": "ConvOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Conv2DModel",
            "bases": [
              "ConvModelBase"
            ],
            "doc": "Conv2D regression model.\n\nInput:\n  x: (B, C_in, H, W)\nOutput:\n  y: (B, C_out, H, W) (same spatial size)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_channels, out_channels, hidden_channels, num_blocks, kernel_size, dropout, residual)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/convolutions/conv3d.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/convolutions/conv3d.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ConvModelBase",
                "as": null
              },
              {
                "name": "ConvOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Conv3DModel",
            "bases": [
              "ConvModelBase"
            ],
            "doc": "Conv3D regression model.\n\nInput:\n  x: (B, C_in, D, H, W)\nOutput:\n  y: (B, C_out, D, H, W)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_channels, out_channels, hidden_channels, num_blocks, kernel_size, dropout, residual)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/convolutions/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/convolutions/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ConvModelBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "conv1d",
            "level": 1,
            "names": [
              {
                "name": "Conv1DModel",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "conv2d",
            "level": 1,
            "names": [
              {
                "name": "Conv2DModel",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "conv3d",
            "level": 1,
            "names": [
              {
                "name": "Conv3DModel",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ConvolutionCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/convolutions/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/convolutions/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ConvModelBase",
                "as": null
              },
              {
                "name": "ConvOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "ConvolutionCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/graphnn/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "GraphBatch",
            "bases": [],
            "doc": "Minimal graph batch format (no external deps).\n\nx:          (B, N, node_dim) node features\npos:        (B, N, pos_dim) optional node coordinates\nedge_index: (2, E) global edges, applied per-graph (shared topology) OR per-batch if you pre-offset\nedge_attr:  (B, E, edge_dim) optional edge features (can be None)\nmask:       (B, N) optional node mask (1 valid, 0 padding)",
            "class_vars": [
              "edge_attr",
              "edge_index",
              "mask",
              "pos",
              "x"
            ],
            "methods": []
          },
          {
            "name": "GraphOutput",
            "bases": [],
            "doc": "Standard output for GNN family.\ny:\n  - node-level: (B, N, out_dim)\n  - graph-level: (B, out_dim) (not used in this MVP)",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "GraphModelBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base for graph models.\n\nMVP uses a simple message passing core (no torch_geometric).",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/graphnn/equivariant_gnn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/equivariant_gnn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "GraphModelBase",
                "as": null
              },
              {
                "name": "GraphBatch",
                "as": null
              },
              {
                "name": "GraphOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "utils",
            "level": 1,
            "names": [
              {
                "name": "scatter_add",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "EquivariantGNN",
            "bases": [
              "GraphModelBase"
            ],
            "doc": "EGNN-style MVP (E(n)-equivariant):\n\n- Maintains node embeddings h and positions p.\n- Updates p using learned, distance-based messages (translation equivariant).\n\nThis is a practical scaffold for meshes/particle systems.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, node_dim, pos_dim, out_dim, *, hidden, layers, edge_dim, dropout, update_pos)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, g, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/graphnn/gnn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/gnn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "GraphModelBase",
                "as": null
              },
              {
                "name": "GraphBatch",
                "as": null
              },
              {
                "name": "GraphOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "utils",
            "level": 1,
            "names": [
              {
                "name": "scatter_add",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "GraphNeuralNetwork",
            "bases": [
              "GraphModelBase"
            ],
            "doc": "Message Passing Neural Network (MVP).\n\nFor each layer:\n  m_ij = phi_m([h_i, h_j, e_ij])\n  agg_i = sum_{j->i} m_ij\n  h_i = phi_u([h_i, agg_i])",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, node_dim, out_dim, *, edge_dim, hidden, layers, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, g, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/graphnn/gnn_ode.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/gnn_ode.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "GraphModelBase",
                "as": null
              },
              {
                "name": "GraphBatch",
                "as": null
              },
              {
                "name": "GraphOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "gnn",
            "level": 1,
            "names": [
              {
                "name": "GraphNeuralNetwork",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_rk4_step",
            "signature": "(f, t, y, dt)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "GraphNeuralODE",
            "bases": [
              "GraphModelBase"
            ],
            "doc": "Graph Neural ODE (MVP):\n\n  dH/dt = f_theta(G, H, t)\nwhere f_theta is a GNN producing node-wise derivatives.\n\nInputs:\n  g: GraphBatch with x as initial node state H(t0)\n  t: (T,) time grid\nOutput:\n  y: (B,T,N,out_dim) (here out_dim == node_dim by default)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, node_dim, *, edge_dim, hidden, layers, method)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, g, t, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/graphnn/graphcast.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/graphcast.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "GraphModelBase",
                "as": null
              },
              {
                "name": "GraphBatch",
                "as": null
              },
              {
                "name": "GraphOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "utils",
            "level": 1,
            "names": [
              {
                "name": "scatter_add",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_ProcessorBlock",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, hidden, edge_dim, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, h, pos, edge_index, edge_attr)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "GraphCast",
            "bases": [
              "GraphModelBase"
            ],
            "doc": "GraphCast-inspired MVP:\n\n  - Node encoder\n  - Processor: K message-passing blocks\n  - Node decoder\n\nInputs:\n  g.x: (B,N,node_in)\n  g.pos: (B,N,pos_dim) optional\n  g.edge_attr: (B,E,edge_dim) optional\nOutput:\n  y: (B,N,out_dim)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, node_in, out_dim, *, hidden, processor_blocks, edge_dim, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, g, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/graphnn/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "GraphModelBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "gnn",
            "level": 1,
            "names": [
              {
                "name": "GraphNeuralNetwork",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "equivariant_gnn",
            "level": 1,
            "names": [
              {
                "name": "EquivariantGNN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "gnn_ode",
            "level": 1,
            "names": [
              {
                "name": "GraphNeuralODE",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "spatiotemporal_gnn",
            "level": 1,
            "names": [
              {
                "name": "SpatiotemporalGNN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "graphcast",
            "level": 1,
            "names": [
              {
                "name": "GraphCast",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "GraphCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/graphnn/spatiotemporal_gnn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/spatiotemporal_gnn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "GraphModelBase",
                "as": null
              },
              {
                "name": "GraphBatch",
                "as": null
              },
              {
                "name": "GraphOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "gnn",
            "level": 1,
            "names": [
              {
                "name": "GraphNeuralNetwork",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "SpatiotemporalGNN",
            "bases": [
              "GraphModelBase"
            ],
            "doc": "Spatiotemporal GNN (MVP):\n\n- Spatial encoder: GNN at each time step\n- Temporal model: GRU over time per-node\n- Head: node-level output per time\n\nInputs:\n  x: (B,T,N,node_in)\n  edge_index: shared across time\nOutput:\n  y: (B,T,N,out_dim)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, node_in, out_dim, *, edge_dim, spatial_hidden, spatial_layers, temporal_hidden, temporal_layers, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, edge_index, *, pos, edge_attr, mask, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/graphnn/utils.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/utils.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "scatter_add",
            "signature": "(src, index, dim_size)",
            "doc": "src: (B, E, F)\nindex: (E,) destination indices [0..N-1]\nreturns: (B, N, F) where output[:, index[e], :] += src[:, e, :]",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_models/graphnn/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/graphnn/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "GraphModelBase",
                "as": null
              },
              {
                "name": "GraphOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "GraphCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/neural_operators/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "OperatorOutput",
            "bases": [],
            "doc": "Standard output for neural operators.\n\ny:\n  - grid operators: (B, ..., out_channels)\n  - point operators: (B, N, out_channels)",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "NeuralOperatorBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base class for Neural Operators.\n\nDesign:\n  - Input represents a function u(x)\n  - Output represents a function G(u)(x)\n  - Geometry / coordinates passed explicitly",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/neural_operators/deeponet.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/deeponet.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorBase",
                "as": null
              },
              {
                "name": "OperatorOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "DeepONet",
            "bases": [
              "NeuralOperatorBase"
            ],
            "doc": "Classic DeepONet:\n  G(u)(x) = sum_k B_k(u) * T_k(x)\n\nBranch net: encodes input function\nTrunk net: encodes coordinates",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, branch_dim, trunk_dim, out_dim, hidden, modes)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, u, coords, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/neural_operators/fno.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/fno.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorBase",
                "as": null
              },
              {
                "name": "OperatorOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_SpectralConv",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_c, out_c, modes)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "FourierNeuralOperator",
            "bases": [
              "NeuralOperatorBase"
            ],
            "doc": "FNO-1D MVP (extendable to 2D/3D).",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_channels, out_channels, width, modes, layers)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, u, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/neural_operators/gno.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/gno.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorBase",
                "as": null
              },
              {
                "name": "OperatorOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "GalerkinNeuralOperator",
            "bases": [
              "NeuralOperatorBase"
            ],
            "doc": "GNO MVP:\n  - Projects input onto learned basis\n  - Applies operator in coefficient space\n  - Reconstructs function",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, basis_dim)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, u, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/neural_operators/ms_deeponet.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/ms_deeponet.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "deeponet",
            "level": 1,
            "names": [
              {
                "name": "DeepONet",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "OperatorOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "MultiScaleDeepONet",
            "bases": [
              "DeepONet"
            ],
            "doc": "Multi-scale DeepONet:\n  - multiple trunk nets at different resolutions\n  - summed contribution",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, branch_dim, trunk_dim, out_dim, scales)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, u, coords, **kw)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/neural_operators/pino.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/pino.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorBase",
                "as": null
              },
              {
                "name": "OperatorOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PhysicsInformedNeuralOperator",
            "bases": [
              "NeuralOperatorBase"
            ],
            "doc": "Wrapper adding physics loss to any operator.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, operator)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *args, physics_fn, physics_data, **kw)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/neural_operators/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "deeponet",
            "level": 1,
            "names": [
              {
                "name": "DeepONet",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "fno",
            "level": 1,
            "names": [
              {
                "name": "FourierNeuralOperator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "gno",
            "level": 1,
            "names": [
              {
                "name": "GalerkinNeuralOperator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "ms_deeponet",
            "level": 1,
            "names": [
              {
                "name": "MultiScaleDeepONet",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pino",
            "level": 1,
            "names": [
              {
                "name": "PhysicsInformedNeuralOperator",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "uno",
            "level": 1,
            "names": [
              {
                "name": "UniversalNeuralOperator",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "NeuralOperatorCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/neural_operators/uno.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/uno.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorBase",
                "as": null
              },
              {
                "name": "OperatorOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "UniversalNeuralOperator",
            "bases": [
              "NeuralOperatorBase"
            ],
            "doc": "Universal Operator Network (MVP):\n  - learned latent representation\n  - coordinate-aware decoding",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, latent_dim, coord_dim, out_dim)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, z, coords, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/neural_operators/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/neural_operators/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorBase",
                "as": null
              },
              {
                "name": "OperatorOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "NeuralOperatorCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/physics_aware/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/physics_aware/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PhysicsAwareOutput",
            "bases": [],
            "doc": null,
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "PhysicsAwareBase",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/physics_aware/pann.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/physics_aware/pann.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PhysicsAwareBase",
                "as": null
              },
              {
                "name": "PhysicsAwareOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PhysicsAwareNeuralNetwork",
            "bases": [
              "PhysicsAwareBase"
            ],
            "doc": "Physics-Aware Neural Network (MVP):\n\nA generic supervised model with an optional physics regularizer hook.\n\nYou provide:\n  - backbone: an nn.Module mapping inputs -> outputs\n  - physics_loss_fn(pred, batch_dict) -> scalar tensor\n\nThis plays nicely with your PINNFactory / UPD:\n  - physics_loss_fn can call symbolic residuals using autodiff.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, backbone, *, physics_loss_fn, physics_weight)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, batch, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/physics_aware/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/physics_aware/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PhysicsAwareBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pann",
            "level": 1,
            "names": [
              {
                "name": "PhysicsAwareNeuralNetwork",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "spn",
            "level": 1,
            "names": [
              {
                "name": "StructurePreservingNetwork",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "PhysicsAwareCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/physics_aware/spn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/physics_aware/spn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PhysicsAwareBase",
                "as": null
              },
              {
                "name": "PhysicsAwareOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "StructurePreservingNetwork",
            "bases": [
              "PhysicsAwareBase"
            ],
            "doc": "Structure-Preserving Network (MVP):\n\nIdea:\n  - Learn an unconstrained predictor y_raw\n  - Apply a projection / correction operator  that enforces structure:\n      y = (y_raw)\nExamples:\n  - non-negativity: clamp\n  - unit vector normalization\n  - divergence-free: projection in Fourier space (future)\n  - energy conservation constraints (approx)\n\nIn MVP,  is user-supplied (callable).",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, backbone, *, projector)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/physics_aware/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/physics_aware/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PhysicsAwareBase",
                "as": null
              },
              {
                "name": "PhysicsAwareOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "PhysicsAwareCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/pinns/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PINNOutput",
            "bases": [],
            "doc": "Standard output for PINN-family models.",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "PINNBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base class for PINN-family models in the catalog.\n\nContract:\n  - forward(*inputs, **kwargs) -> PINNOutput\n  - physics_loss(...) optional hook:\n      can be driven by pinneaple_pinn.factory loss_fn or other physics term.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "predict",
                "signature": "(self, *inputs, **kwargs)",
                "doc": "By default, forward returns PINNOutput; predict returns y only.",
                "decorators": []
              },
              {
                "name": "physics_loss",
                "signature": "(self, *, physics_fn, physics_data, **kwargs)",
                "doc": "Default: no physics.\nIf you provide physics_fn, we call it and expect (total_loss, loss_components) OR dict.",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/inverse.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/inverse.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PINNBase",
                "as": null
              },
              {
                "name": "PINNOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "vanilla",
            "level": 1,
            "names": [
              {
                "name": "_act",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_FactoryPINNAdapter",
            "bases": [
              "nn.Module"
            ],
            "doc": "Adapter to make catalog-style models compatible with PINNFactory.\n\nRequirements from PINNFactory / DerivativeComputer:\n  - model(*inputs) returns Tensor (B, out_dim)\n  - model.inverse_params is a nn.ParameterDict with required names",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, core, num_inputs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "inverse_params",
                "signature": "(self)",
                "doc": null,
                "decorators": [
                  "property"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, *inputs)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "InversePINN",
            "bases": [
              "PINNBase"
            ],
            "doc": "Catalog InversePINN (returns PINNOutput), with a compatibility hook for PINNFactory.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, hidden, activation, inverse_params, initial_guesses)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "as_factory_model",
                "signature": "(self, *, independent_vars)",
                "doc": "Returns an nn.Module compatible with PINNFactory:\n  - forward(*inputs) -> Tensor\n  - exposes .inverse_params\n\nindependent_vars is only used for sanity (len check).",
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, physics_fn, physics_data)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/pielm.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/pielm.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "import",
            "name": "torch.nn.functional",
            "as": "F"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PINNBase",
                "as": null
              },
              {
                "name": "PINNOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PIELM",
            "bases": [
              "PINNBase"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, hidden_dim, activation, freeze_random)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "hidden",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward_tensor",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit_ridge",
                "signature": "(self, x, y, l2)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, data_weight, physics_weight, physics_fn, physics_data, data_reduction)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "PIELMFactoryAdapter",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, pielm, *, inverse_params_names, initial_guesses, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *inputs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit_ridge_from_inputs",
                "signature": "(self, inputs, y, l2)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/pinnsformer.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/pinnsformer.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PINNsFormer",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, *, seq_len, d_model, nhead, num_layers, dim_feedforward, dropout, max_len, learnable_pos_emb)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_sinusoidal_pe",
                "signature": "(max_len, d_model)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "set_masks",
                "signature": "(self, *, attn_mask, key_padding_mask)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *inputs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/pinn_lstm.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/pinn_lstm.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PINNLSTM",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, *, seq_len, hidden_dim, num_layers, dropout, inverse_params_names, initial_guesses, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_ensure_n1",
                "signature": "(a)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, *inputs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PINNBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "vanilla",
            "level": 1,
            "names": [
              {
                "name": "VanillaPINN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "inverse",
            "level": 1,
            "names": [
              {
                "name": "InversePINN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pielm",
            "level": 1,
            "names": [
              {
                "name": "PIELM",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinn_lstm",
            "level": 1,
            "names": [
              {
                "name": "PINNLSTM",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinnsformer",
            "level": 1,
            "names": [
              {
                "name": "PINNsFormer",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "vpinn",
            "level": 1,
            "names": [
              {
                "name": "VPINN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "xpinn",
            "level": 1,
            "names": [
              {
                "name": "XPINN",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "xtfc",
            "level": 1,
            "names": [
              {
                "name": "XTFC",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "PINNCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/vanilla.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/vanilla.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PINNBase",
                "as": null
              },
              {
                "name": "PINNOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_act",
            "signature": "(name)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "VanillaPINN",
            "bases": [
              "PINNBase"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, hidden, activation, *, inverse_params_names, initial_guesses, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_concat_inputs",
                "signature": "(self, inputs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *inputs, physics_fn, physics_data)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/vpinn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/vpinn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [
          {
            "name": "_act",
            "signature": "(name)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "pinn_factory_adapter",
            "signature": "(loss_fn)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "PINNOutput",
            "bases": [],
            "doc": null,
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "PINNBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base class for PINN-family models in the catalog.\n\nContract:\n  - forward(...) -> PINNOutput\n  - physics_loss(...) optional hook:\n      can be driven by pinneaple_pinn.factory loss_fn or other physics term.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "predict",
                "signature": "(self, *inputs, **kwargs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_ref_tensor",
                "signature": "(self, **kwargs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_zero_scalar",
                "signature": "(self, ref)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_to_scalar_tensor",
                "signature": "(self, v, ref)",
                "doc": "Converte v para escalar tensor no device/dtype de ref.\nSe v for tensor no-escalar, reduz por sum().",
                "decorators": []
              },
              {
                "name": "physics_loss",
                "signature": "(self, *, physics_fn, physics_data, **kwargs)",
                "doc": "Default: no physics.\nIf you provide physics_fn, we call it and expect:\n  - (total_loss, components_dict) OR\n  - dict[str, tensor/number]",
                "decorators": []
              }
            ]
          },
          {
            "name": "VPINN",
            "bases": [
              "PINNBase"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, hidden, activation, *, inverse_params_names, initial_guesses, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_pack_inputs",
                "signature": "(self, *inputs, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *inputs, physics_fn, physics_data, weak_fn, weak_data, x, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/xpinn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/xpinn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [
          {
            "name": "_act",
            "signature": "(name)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "VanillaPINN",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, hidden, activation)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "PINNOutput",
            "bases": [],
            "doc": null,
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "PINNBase",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_ref_tensor",
                "signature": "(self, *maybe)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_zeros",
                "signature": "(self, like)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "predict",
                "signature": "(self, *inputs, **kwargs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "ensure_requires_grad",
                "signature": "(x)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "grad",
                "signature": "(y, x, *, retain_graph, create_graph)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "normal_derivative",
                "signature": "(cls, y, x, n_hat)",
                "doc": null,
                "decorators": [
                  "classmethod"
                ]
              },
              {
                "name": "physics_loss",
                "signature": "(self, *, physics_fn, physics_data, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "SubnetWrapper",
            "bases": [
              "PINNBase"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, hidden, activation)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *inputs)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "XPINN",
            "bases": [
              "PINNBase"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, n_subdomains, in_dim, out_dim, hidden, activation, interface_weight, interface_flux_weight, physics_weight)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_list, *, interface_pairs, physics_fn, physics_data_list)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/xtfc.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/xtfc.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [
          {
            "name": "_get_phi",
            "signature": "(name)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "PINNOutput",
            "bases": [],
            "doc": null,
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "PINNBase",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "predict",
                "signature": "(self, *inputs, **kwargs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "physics_loss",
                "signature": "(self, *, physics_fn, physics_data)",
                "doc": "Optional hook (kept for catalog-compatibility).\nYour PINNFactory integration will NOT use this hook;\nit uses loss_fn(model, batch) instead.",
                "decorators": []
              }
            ]
          },
          {
            "name": "XTFCConfig",
            "bases": [],
            "doc": null,
            "class_vars": [
              "activation",
              "broadcast_B",
              "clamp_B",
              "eps_B",
              "freeze_random",
              "head_bias",
              "in_dim",
              "init_scale",
              "l2_W",
              "l2_head",
              "out_dim",
              "rf_dim",
              "rf_kind",
              "rff_sigma",
              "use_bias"
            ],
            "methods": []
          },
          {
            "name": "XTFC",
            "bases": [
              "PINNBase"
            ],
            "doc": "XTFC (Extreme Theory of Functional Connections)\n\ny(x) = g(x) + B(x) * N(x)\n\n- g(x): satisfies constraints (IC/BC) exactly (user-provided)\n- B(x): vanishes on constraint boundaries (user-provided)\n- N(x): flexible approximator (random features + linear head)\n\nThis class is catalog-friendly (returns PINNOutput),\nand ALSO exposes forward_tensor(x) for PINNFactory integration.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, rf_dim, activation, freeze_random, g_fn, B_fn, *, config)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_rf_out_dim",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_init_random_features",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "reset_random_features",
                "signature": "(self, seed)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "_rf",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit_ridge",
                "signature": "(self, x, y_target, *, l2)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "_compute_g",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_compute_B",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward_tensor",
                "signature": "(self, x)",
                "doc": "Tensor-only forward for PINNFactory compatibility.\nx: (N, in_dim)\nreturns: (N, out_dim)",
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, physics_fn, physics_data, return_parts)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "XTFCFactoryModel",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, xtfc, inverse_params_names, initial_guesses, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *inputs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/pinns/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/pinns/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "PINNBase",
                "as": null
              },
              {
                "name": "PINNOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "PINNCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/recurrent/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/recurrent/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "RNNOutput",
            "bases": [],
            "doc": "Standard output for recurrent models in Pinneaple.",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "RecurrentModelBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base class for time-series recurrent models.\n\nConventions (MVP):\n  - x_past:  (B, L, in_dim)\n  - y_hat:   (B, H, out_dim)\n  - horizon passed at init",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/recurrent/gru.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/recurrent/gru.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RecurrentModelBase",
                "as": null
              },
              {
                "name": "RNNOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "GRUModel",
            "bases": [
              "RecurrentModelBase"
            ],
            "doc": "GRU forecaster.\n\nInputs:\n  x_past: (B, L, in_dim)\nOutput:\n  y_hat:  (B, H, out_dim) using the last hidden state repeated (MVP).",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, hidden_dim, num_layers, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "BiGRUModel",
            "bases": [
              "RecurrentModelBase"
            ],
            "doc": "Bidirectional GRU forecaster.\n\nMVP decoding:\n  - concatenates last layer forward+backward hidden and repeats over horizon.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, hidden_dim, num_layers, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/recurrent/lstm.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/recurrent/lstm.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RecurrentModelBase",
                "as": null
              },
              {
                "name": "RNNOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "LSTMModel",
            "bases": [
              "RecurrentModelBase"
            ],
            "doc": "LSTM forecaster.\n\nMVP decoding:\n  - repeats last hidden state over horizon.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, hidden_dim, num_layers, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "BiLSTMModel",
            "bases": [
              "RecurrentModelBase"
            ],
            "doc": "Bidirectional LSTM forecaster.\n\nMVP decoding:\n  - concat forward/backward last hidden, repeat over horizon.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, hidden_dim, num_layers, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/recurrent/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/recurrent/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RecurrentModelBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "gru",
            "level": 1,
            "names": [
              {
                "name": "GRUModel",
                "as": null
              },
              {
                "name": "BiGRUModel",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "lstm",
            "level": 1,
            "names": [
              {
                "name": "LSTMModel",
                "as": null
              },
              {
                "name": "BiLSTMModel",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "seq2seq",
            "level": 1,
            "names": [
              {
                "name": "Seq2SeqRNN",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "RecurrentCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/recurrent/seq2seq.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/recurrent/seq2seq.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RecurrentModelBase",
                "as": null
              },
              {
                "name": "RNNOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Seq2SeqRNN",
            "bases": [
              "RecurrentModelBase"
            ],
            "doc": "Seq2Seq RNN forecaster (MVP).\n\nEncoder: GRU/LSTM\nDecoder: GRU/LSTM generating H steps autoregressively (optionally teacher forcing).\n\nInputs:\n  x_past:  (B, L, in_dim)\n  x_future:(B, H, future_dim) optional known future features (calendar/forcing)\n  y_future:(B, H, out_dim) optional teacher forcing targets\n\nOutput:\n  y_hat:   (B, H, out_dim)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, hidden_dim, num_layers, dropout, cell, future_dim)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, x_future, y_future, teacher_forcing, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/recurrent/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/recurrent/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RecurrentModelBase",
                "as": null
              },
              {
                "name": "RNNOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "RecurrentCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/reservoir_computing/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "RCOutput",
            "bases": [],
            "doc": "Standard output for reservoir computing models.\n\ny:\n  - sequence models: (B, T, out_dim)\n  - static models: (B, out_dim)",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "RCBase",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "ridge_solve",
                "signature": "(X, Y, l2)",
                "doc": "Closed-form ridge regression: W = (X^T X + l2 I)^-1 X^T Y\n\nX: (N, F)\nY: (N, O)\nreturns W: (F, O)",
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/reservoir_computing/elm.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/elm.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RCBase",
                "as": null
              },
              {
                "name": "RCOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ExtremeLearningMachine",
            "bases": [
              "RCBase"
            ],
            "doc": "Extreme Learning Machine (ELM):\n  - Random hidden layer features: H = phi(X W + b)\n  - Solve output weights with ridge regression (closed-form)\n\nWorks for:\n  - static regression/classification (MVP: regression)\n\nInput:\n  x: (B, in_dim) or (N, in_dim)\nOutput:\n  y: (B, out_dim)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, hidden_dim, activation, l2, freeze_random)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_features",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, x, y)",
                "doc": "x: (N,in_dim)\ny: (N,out_dim)",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/reservoir_computing/esn.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/esn.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RCBase",
                "as": null
              },
              {
                "name": "RCOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_spectral_radius",
            "signature": "(W, iters)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "EchoStateNetwork",
            "bases": [
              "RCBase"
            ],
            "doc": "Echo State Network (ESN):\n  h_t = (1-leak)*h_{t-1} + leak*tanh(W_in x_t + W h_{t-1})\n  y_t = [h_t, x_t, 1] W_out  (trained by ridge)\n\nInput:\n  x: (B,T,in_dim)\nOutput:\n  y: (B,T,out_dim)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, reservoir_dim, spectral_radius, leak, input_scale, l2, use_skip, use_bias, freeze_random)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_step",
                "signature": "(self, x_t, h)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_readout_features",
                "signature": "(self, h, x_t)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, x, y, *, washout)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss, washout)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/reservoir_computing/esn_rc.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/esn_rc.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RCBase",
                "as": null
              },
              {
                "name": "RCOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "esn",
            "level": 1,
            "names": [
              {
                "name": "EchoStateNetwork",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ESNRC",
            "bases": [
              "RCBase"
            ],
            "doc": "ESN-RC (Reservoir Computing) variant:\n  - Uses ESN reservoir but augments readout with nonlinear transforms\n    (e.g., h, h^2, h^3) to approximate richer dynamics while keeping\n    closed-form ridge training.\n\nThis is a common physics RC trick when dynamics are polynomial-like.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, reservoir_dim, *, spectral_radius, leak, input_scale, l2, poly_degree, use_skip, use_bias)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_features",
                "signature": "(self, h, x_t)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, x, y, *, washout)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss, washout)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/reservoir_computing/hybrid_rbf.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/hybrid_rbf.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RCBase",
                "as": null
              },
              {
                "name": "RCOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "rbf",
            "level": 1,
            "names": [
              {
                "name": "RBFNetwork",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "HybridRBFNetwork",
            "bases": [
              "RCBase"
            ],
            "doc": "Hybrid RBF Network:\n  y = Phi(x) W_rbf + x W_lin + b\nwhere W_* solved by ridge regression in a single linear system.\n\nThis is often much stronger than pure RBF on real physics data.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, num_centers, sigma, l2, learn_centers, use_linear, use_bias)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_features",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, x, y, *, init_centers_from_data)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/reservoir_computing/koopman.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/koopman.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RCBase",
                "as": null
              },
              {
                "name": "RCOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "KoopmanOperator",
            "bases": [
              "RCBase"
            ],
            "doc": "Koopman Operator (EDMD-style MVP):\n\nLearn a linear operator K in a lifted space:\n  z = phi(x)\n  z_{t+1} = K z_t\n  x_{t} ~ decode(z_t)  (optional)\n\nMVP:\n  - phi is random Fourier features (RBF-like) or polynomial lift\n  - fit K by least squares: K = Z_{t+1} * pinv(Z_t)\n  - prediction by iterating K\n\nInputs:\n  x: (B,T,in_dim)\nOutputs:\n  y: predicted x (B,T,out_dim==in_dim by default)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, *, lift_dim, lift, poly_degree, rff_lengthscale, l2, use_bias, freeze_lift)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_lift",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, x)",
                "doc": "x: (B,T,in_dim) trajectory batch.\nFit K using EDMD: Z1 ~ K Z0",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "rollout",
                "signature": "(self, x0, steps)",
                "doc": "x0: (B,in_dim)\nreturns x_hat: (B,steps+1,in_dim)",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/reservoir_computing/rbf.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/rbf.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RCBase",
                "as": null
              },
              {
                "name": "RCOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "RBFNetwork",
            "bases": [
              "RCBase"
            ],
            "doc": "RBF Network:\n  - Centers C (learned or fixed)\n  - Features: phi_i(x) = exp(-||x-C_i||^2 / (2*sigma^2))\n  - Output weights solved by ridge regression (MVP)\n\nFit:\n  - If centers not provided: sample from x (simple init)\n  - sigma based on median distance heuristic (optional)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, num_centers, sigma, l2, learn_centers)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_phi",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, x, y, *, init_centers_from_data)",
                "doc": "x: (N,in_dim), y: (N,out_dim)",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x, *, y_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/reservoir_computing/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RCBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "elm",
            "level": 1,
            "names": [
              {
                "name": "ExtremeLearningMachine",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "rbf",
            "level": 1,
            "names": [
              {
                "name": "RBFNetwork",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "hybrid_rbf",
            "level": 1,
            "names": [
              {
                "name": "HybridRBFNetwork",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "esn",
            "level": 1,
            "names": [
              {
                "name": "EchoStateNetwork",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "esn_rc",
            "level": 1,
            "names": [
              {
                "name": "ESNRC",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "koopman",
            "level": 1,
            "names": [
              {
                "name": "KoopmanOperator",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ReservoirCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/reservoir_computing/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/reservoir_computing/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "RCBase",
                "as": null
              },
              {
                "name": "RCOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "ReservoirCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/rom/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ROMOutput",
            "bases": [],
            "doc": "Output for Reduced Order Models.\n\ny:\n  - reconstructed field or predicted latent/state trajectory",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "ROMBase",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/rom/deep_uq_rom.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/deep_uq_rom.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "import",
            "name": "torch.nn.functional",
            "as": "F"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ROMBase",
                "as": null
              },
              {
                "name": "ROMOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "DeepUQROM",
            "bases": [
              "ROMBase"
            ],
            "doc": "Deep UQ-ROM (MVP scaffold):\n  - A small latent predictor that outputs mean and log-variance.\n\nIntended use:\n  - plug after POD encoder\n  - train with NLL (Gaussian)\n\nInputs:\n  a: (B,T,r) latent\nOutputs:\n  a_hat_mean, a_hat_logvar",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, r, hidden, layers, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, a, *, a_true, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/rom/dmd.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/dmd.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ROMBase",
                "as": null
              },
              {
                "name": "ROMOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "DynamicModeDecomposition",
            "bases": [
              "ROMBase"
            ],
            "doc": "DMD MVP:\n  Given snapshots X0 = [x0..x_{T-2}], X1 = [x1..x_{T-1}]\n  Fit linear operator A in reduced space:\n    A = X1 * pinv(X0)\nSupports:\n  - optional truncation rank r (SVD)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, r, center, l2)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, X)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "rollout",
                "signature": "(self, x0, steps)",
                "doc": "x0: (B,D) in original space\nreturns: (B,steps+1,D)",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, X, *, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/rom/havok.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/havok.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ROMBase",
                "as": null
              },
              {
                "name": "ROMOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dmd",
            "level": 1,
            "names": [
              {
                "name": "DynamicModeDecomposition",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "HAVOK",
            "bases": [
              "ROMBase"
            ],
            "doc": "HAVOK (MVP):\n  - build Hankel (delay embedding) from scalar or low-dim observations\n  - apply DMD in embedded space\n  - reconstruct embedded trajectory (and optionally map back)\n\nNotes:\n  Full HAVOK also separates forcing term; this MVP focuses on the\n  delay-embedding + linear model core.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, delays, r, center)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_hankel",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, X)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, X, *, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/rom/opinf.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/opinf.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ROMBase",
                "as": null
              },
              {
                "name": "ROMOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "OperatorInference",
            "bases": [
              "ROMBase"
            ],
            "doc": "Operator Inference (OpInf) MVP:\n\nFit latent dynamics:\n  a_{t+1} = A a_t + H (a_t  a_t) + b\n\n- You provide latent trajectories a (e.g. from POD encoder)\n- Fit A, H, b by ridge regression\n\nShapes:\n  a: (B,T,r)\n  A: (r,r)\n  H: (r, r*r)\n  b: (r,)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, r, l2, use_quadratic, use_bias)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_features",
                "signature": "(self, a)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_ridge_solve",
                "signature": "(X, Y, l2)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "fit",
                "signature": "(self, a)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "rollout",
                "signature": "(self, a0, steps)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, a, *, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/rom/pod.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/pod.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ROMBase",
                "as": null
              },
              {
                "name": "ROMOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "POD",
            "bases": [
              "ROMBase"
            ],
            "doc": "POD via SVD.\n\nFit:\n  snapshots X: (N_snap, D) or (B,T,D) -> flattened to (N, D)\n\nProduces:\n  U_r: (D, r) basis\n  a:   (N, r) coefficients\n\nReconstruct:\n  X_hat = a U_r^T",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, r, center)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, X)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "encode",
                "signature": "(self, X)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, a, *, shape)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, X, *, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/rom/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ROMBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pod",
            "level": 1,
            "names": [
              {
                "name": "POD",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dmd",
            "level": 1,
            "names": [
              {
                "name": "DynamicModeDecomposition",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "havok",
            "level": 1,
            "names": [
              {
                "name": "HAVOK",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "opinf",
            "level": 1,
            "names": [
              {
                "name": "OperatorInference",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "rom_hybrid",
            "level": 1,
            "names": [
              {
                "name": "ROMHybrid",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "deep_uq_rom",
            "level": 1,
            "names": [
              {
                "name": "DeepUQROM",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ROMCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/rom/rom_hybrid.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/rom_hybrid.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ROMBase",
                "as": null
              },
              {
                "name": "ROMOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pod",
            "level": 1,
            "names": [
              {
                "name": "POD",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "opinf",
            "level": 1,
            "names": [
              {
                "name": "OperatorInference",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ROMHybrid",
            "bases": [
              "ROMBase"
            ],
            "doc": "ROM Hybrid (MVP):\n  - POD encoder/decoder for fields\n  - OperatorInference (latent dynamics)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, field_dim, r, l2)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, X)",
                "doc": null,
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, X, *, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/rom/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/rom/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "ROMBase",
                "as": null
              },
              {
                "name": "ROMOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "ROMCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_models/transformers/autoformer.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/autoformer.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesModelBase",
                "as": null
              },
              {
                "name": "TSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_SeriesDecomp",
            "bases": [
              "nn.Module"
            ],
            "doc": "Simple moving-average decomposition (trend + seasonal).",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, kernel_size)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "Autoformer",
            "bases": [
              "TimeSeriesModelBase"
            ],
            "doc": "Autoformer (MVP approximation):\n  - Series decomposition into trend/seasonal\n  - Then apply attention-style encoder (standard Transformer in MVP)\n  - Predict horizon by extending trend + forecasting seasonal\n\nThis is a scaffold; later you can replace attention with AutoCorrelation.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, d_model, nhead, num_layers, kernel_size, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, x_future, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/transformers/base.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "TSOutput",
            "bases": [],
            "doc": "Standard output for time-series transformers in Pinneaple.",
            "class_vars": [
              "extras",
              "losses",
              "y"
            ],
            "methods": []
          },
          {
            "name": "TimeSeriesModelBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base class for sequence forecasting models.\n\nConventions (MVP):\n  - x_past:  (B, L, in_dim)\n  - x_future:(B, H, future_dim) optional known future features (calendar, forcing, etc.)\n  - returns y: (B, H, out_dim)\n\nThe models themselves are architecture-only; training module will handle splits/metrics later.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, x_future, y_future, return_loss)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(y_hat, y)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/transformers/fedformer.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/fedformer.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesModelBase",
                "as": null
              },
              {
                "name": "TSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "FEDformer",
            "bases": [
              "TimeSeriesModelBase"
            ],
            "doc": "FEDformer (MVP approximation):\n  - Frequency enhanced model; MVP uses FFT-based projection + lightweight MLP head.\n\nLater you can replace this with spectral attention blocks.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, d_model, topk_freq)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, x_future, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/transformers/informer.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/informer.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesModelBase",
                "as": null
              },
              {
                "name": "TSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Informer",
            "bases": [
              "TimeSeriesModelBase"
            ],
            "doc": "Informer (MVP approximation):\n  - Transformer encoder with lightweight attention (we approximate with standard attention in MVP)\n  - Distilling via Conv1d downsampling between encoder layers (optional)\n\nThis is a usable scaffold; you can later replace attention with ProbSparse.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, d_model, nhead, num_layers, dim_feedforward, dropout, distill, future_dim)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, x_future, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/transformers/registry.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesModelBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "transformer",
            "level": 1,
            "names": [
              {
                "name": "VanillaTransformer",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "informer",
            "level": 1,
            "names": [
              {
                "name": "Informer",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "tft",
            "level": 1,
            "names": [
              {
                "name": "TemporalFusionTransformer",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "autoformer",
            "level": 1,
            "names": [
              {
                "name": "Autoformer",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "fedformer",
            "level": 1,
            "names": [
              {
                "name": "FEDformer",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "timesnet",
            "level": 1,
            "names": [
              {
                "name": "TimesNet",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "register_into_global",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "TransformerCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/transformers/tft.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/tft.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesModelBase",
                "as": null
              },
              {
                "name": "TSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_GatedResidualNetwork",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, d, hidden, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "TemporalFusionTransformer",
            "bases": [
              "TimeSeriesModelBase"
            ],
            "doc": "TFT (MVP):\n  - GRN blocks + self-attention + output head\n  - Focus on practicality; missing some TFT specifics (static covariates, variable selection) in MVP",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, d_model, nhead, num_layers, dropout)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, x_future, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/transformers/timesnet.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/timesnet.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesModelBase",
                "as": null
              },
              {
                "name": "TSOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "_InceptionBlock1D",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, d, k_sizes)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "TimesNet",
            "bases": [
              "TimeSeriesModelBase"
            ],
            "doc": "TimesNet (MVP approximation):\n  - multi-period temporal modeling using conv/inception over the sequence.\n  - we keep it simple: inception blocks + horizon head.\n\nLater you can add explicit period discovery / reshaping.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, horizon, d_model, num_blocks)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x_past, *, x_future, y_future, return_loss)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/transformers/transformer.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/transformer.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesModelBase",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "VanillaTransformer",
            "bases": [
              "TimeSeriesModelBase"
            ],
            "doc": "Vanilla Transformer encoder for time series (MVP).\n\nInput:\n  x: (B, T, D)\n\nOutput:\n  - If pool=\"none\": (B, T, out_dim)\n  - If pool=\"mean\" or \"last\": (B, out_dim)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, in_dim, out_dim, d_model, nhead, num_layers, dim_feedforward, dropout, pool)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_models/transformers/__init__.py": {
      "package": "pinneaple_models",
      "path": "pinneaple_models/transformers/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesModelBase",
                "as": null
              },
              {
                "name": "TSOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "TransformerCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_pdb/builder.py": {
      "package": "pinneaple_pdb",
      "path": "pinneaple_pdb/builder.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "import",
            "name": "hashlib",
            "as": null
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              },
              {
                "name": "asdict",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "pandas",
            "as": "pd"
          },
          {
            "type": "import",
            "name": "xarray",
            "as": "xr"
          },
          {
            "type": "import",
            "name": "earthaccess",
            "as": null
          },
          {
            "type": "from",
            "module": "cmr",
            "level": 0,
            "names": [
              {
                "name": "GranuleQuery",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "templates",
            "level": 1,
            "names": [
              {
                "name": "schema_templates",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "validate",
            "level": 1,
            "names": [
              {
                "name": "ValidationSpec",
                "as": null
              },
              {
                "name": "standardize_dims",
                "as": null
              },
              {
                "name": "validate_dataset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "derived",
            "level": 1,
            "names": [
              {
                "name": "DerivedSpec",
                "as": null
              },
              {
                "name": "apply_derived",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "shard",
            "level": 1,
            "names": [
              {
                "name": "ShardSpec",
                "as": null
              },
              {
                "name": "iter_time_windows",
                "as": null
              },
              {
                "name": "subset_time",
                "as": null
              },
              {
                "name": "iter_tiles",
                "as": null
              },
              {
                "name": "subset_tile",
                "as": null
              },
              {
                "name": "regime_tags_for",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_uid",
            "signature": "(txt)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_ensure_dir",
            "signature": "(p)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_normalize_time",
            "signature": "(s)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_temporal",
            "signature": "(time_start, time_end)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_match",
            "signature": "(names, patterns)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_resolve_packs",
            "signature": "(packs, available, packs_dict)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_pick_url",
            "signature": "(granule, prefer)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "HubQuery",
            "bases": [],
            "doc": null,
            "class_vars": [
              "keyword",
              "provider",
              "short_name"
            ],
            "methods": []
          },
          {
            "name": "SpaceTime",
            "bases": [],
            "doc": null,
            "class_vars": [
              "bbox",
              "chunking",
              "stride",
              "time_end",
              "time_start"
            ],
            "methods": []
          },
          {
            "name": "VariableSelection",
            "bases": [],
            "doc": null,
            "class_vars": [
              "exclude",
              "include",
              "packs"
            ],
            "methods": []
          },
          {
            "name": "PhysicalSchema",
            "bases": [],
            "doc": null,
            "class_vars": [
              "bcs",
              "forcings",
              "governing_equations",
              "ics",
              "physical_system",
              "regime_tags",
              "units_policy",
              "validity",
              "version"
            ],
            "methods": []
          },
          {
            "name": "PhysicalDatasetBuilder",
            "bases": [],
            "doc": "MVP-1 builder:\n  - time-window sharding (and optional spatial tiles)\n  - derived: vorticity/divergence\n  - validations: units/ranges/monotonic\n  - CLI friendly",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, packs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "login",
                "signature": "(self, persist)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list_collections",
                "signature": "(self, keyword, provider, short_name, limit)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "set_dataset",
                "signature": "(self, provider, short_name, keyword)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "set_spacetime",
                "signature": "(self, time_start, time_end, bbox, stride, chunking)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "set_selection",
                "signature": "(self, include, exclude, packs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "set_schema_from_template",
                "signature": "(self, template_id)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "set_schema",
                "signature": "(self, schema)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "inspect",
                "signature": "(self, prefer, engine, chunks, max_granules)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, out_dir, catalog_path, shards, derived, validate, prefer, engine, chunks, max_granules)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_search_granules",
                "signature": "(self, max_granules)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_write_upd",
                "signature": "(self, ds, out_dir, catalog_path, url, notes, t0, t1, tags, tile)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_suggest_packs",
                "signature": "(self, available_vars, top_k)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_pdb/derived.py": {
      "package": "pinneaple_pdb",
      "path": "pinneaple_pdb/derived.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "xarray",
            "as": "xr"
          }
        ],
        "functions": [
          {
            "name": "_infer_uv",
            "signature": "(ds, u_name, v_name)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "add_vorticity_divergence",
            "signature": "(ds, u_name, v_name)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "apply_derived",
            "signature": "(ds, spec)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "DerivedSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "derived",
              "u_name",
              "v_name"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_pdb/shard.py": {
      "package": "pinneaple_pdb",
      "path": "pinneaple_pdb/shard.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Iterator",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "pandas",
            "as": "pd"
          },
          {
            "type": "import",
            "name": "xarray",
            "as": "xr"
          }
        ],
        "functions": [
          {
            "name": "iter_time_windows",
            "signature": "(time_values, window)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "subset_time",
            "signature": "(ds, a, b)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "iter_tiles",
            "signature": "(lat_vals, lon_vals, dlat, dlon)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "subset_tile",
            "signature": "(ds, lat0, lat1, lon0, lon1)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "regime_tags_for",
            "signature": "(ds)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ShardSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "add_regime_tags",
              "tile_deg",
              "time_window"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_pdb/templates.py": {
      "package": "pinneaple_pdb",
      "path": "pinneaple_pdb/templates.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "schema_templates",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_pdb/validate.py": {
      "package": "pinneaple_pdb",
      "path": "pinneaple_pdb/validate.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "xarray",
            "as": "xr"
          }
        ],
        "functions": [
          {
            "name": "standardize_dims",
            "signature": "(ds)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_sample_flat",
            "signature": "(da, max_n)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "validate_dataset",
            "signature": "(ds, spec)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "ValidationSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "enforce_lev_monotonic",
              "enforce_time_monotonic",
              "ranges",
              "require_units"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_pdb/__init__.py": {
      "package": "pinneaple_pdb",
      "path": "pinneaple_pdb/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "builder",
            "level": 1,
            "names": [
              {
                "name": "PhysicalDatasetBuilder",
                "as": null
              },
              {
                "name": "HubQuery",
                "as": null
              },
              {
                "name": "SpaceTime",
                "as": null
              },
              {
                "name": "VariableSelection",
                "as": null
              },
              {
                "name": "PhysicalSchema",
                "as": null
              },
              {
                "name": "ShardSpec",
                "as": null
              },
              {
                "name": "DerivedSpec",
                "as": null
              },
              {
                "name": "ValidationSpec",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "templates",
            "level": 1,
            "names": [
              {
                "name": "schema_templates",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_pinn/__init__.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_pinn/factory/autodiff.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/factory/autodiff.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "sympy",
            "as": "sp"
          }
        ],
        "functions": [
          {
            "name": "_safe_grad",
            "signature": "(outputs, inputs)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "ensure_requires_grad",
            "signature": "(inputs)",
            "doc": "Ensures all tensors in `inputs` have requires_grad=True (in-place).",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "DerivativeKey",
            "bases": [],
            "doc": "A stable key for caching derivative computations.\n\nExample:\n  - base: \"u\"\n  - wrt: [(\"x\", 1), (\"t\", 2)] means d^3 u / dx dt^2",
            "class_vars": [
              "base",
              "wrt"
            ],
            "methods": []
          },
          {
            "name": "DerivativeComputer",
            "bases": [],
            "doc": "Computes and caches torch autograd derivatives required by SymPy Derivative atoms.\n\nHow it works:\n  - model outputs are split into named dependent variables\n  - for each needed derivative, autograd.grad is applied repeatedly\n  - results cached by DerivativeKey for reuse across equations/conditions",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, independent_vars, dependent_vars, device)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "sympy_derivative_to_key",
                "signature": "(self, d)",
                "doc": "Converts SymPy Derivative(u(x,t), x, t, t) into DerivativeKey(\"u\", ((\"x\",1),(\"t\",2)))",
                "decorators": []
              },
              {
                "name": "compute",
                "signature": "(self, model, inputs, required_derivatives, dep_symbols)",
                "doc": "Returns mapping:\n  - dep symbol (e.g. u(x,t)) -> predicted tensor (N,1)\n  - derivative atoms -> tensor (N,1)\n\ndep_symbols: mapping from dep var name to sympy \"u(x,t)\" object",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_pinn/factory/pinn_factory.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/factory/pinn_factory.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "collections",
            "as": null
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "import",
            "name": "sympy",
            "as": "sp"
          },
          {
            "type": "from",
            "module": "sympy_backend",
            "level": 1,
            "names": [
              {
                "name": "SympyTorchCompiler",
                "as": null
              },
              {
                "name": "CompiledEquation",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "autodiff",
            "level": 1,
            "names": [
              {
                "name": "DerivativeComputer",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "NeuralNetwork",
            "bases": [
              "nn.Module"
            ],
            "doc": "A simple fully-connected MLP.\n\nforward(*inputs): concatenates along dim=1",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, num_inputs, num_outputs, num_layers, num_neurons, activation)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *inputs)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "PINN",
            "bases": [
              "nn.Module"
            ],
            "doc": "Wraps a neural network plus trainable inverse parameters.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, neural_network, inverse_params_names, initial_guesses, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *inputs)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "PINNProblemSpec",
            "bases": [],
            "doc": "A model-agnostic PINN specification.\n\npde_residuals: list of equations that should be ~0 on collocation points\nconditions: list of dicts like:\n  {\n    \"name\": \"ic_u\",\n    \"equation\": \"u - sin(pi*x)\",\n    \"weight\": 1.0\n  }\nindependent_vars: e.g. [\"t\",\"x\"] or [\"t\",\"lat\",\"lon\",\"lev\"]\ndependent_vars: e.g. [\"u\"] or [\"T\",\"U\",\"V\"]\ninverse_params: optional list of trainable scalars used in equations\nloss_weights: weights for loss buckets: {\"pde\":1.0,\"conditions\":1.0,\"data\":1.0}",
            "class_vars": [
              "conditions",
              "dependent_vars",
              "independent_vars",
              "inverse_params",
              "loss_weights",
              "pde_residuals",
              "verbose"
            ],
            "methods": []
          },
          {
            "name": "PINNFactory",
            "bases": [],
            "doc": "Factory that compiles symbolic equations (SymPy) into torch-callable residuals,\nthen creates a unified loss function.\n\nData contract for the generated loss(model, batch):\n  batch can contain:\n    - \"collocation\": Tuple[Tensor,...]  # for PDE residuals\n    - \"conditions\": List[Tuple[Tensor,...]]  # one per condition equation (same length as spec.conditions)\n    - \"data\": (Tuple[Tensor,...], Tensor)  # supervised data pairs",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, spec)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_print_summary",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "generate_loss_function",
                "signature": "(self)",
                "doc": "Returns (loss_fn) where:\n  loss_fn(model, batch) -> (total_loss, components_dict)",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_pinn/factory/sympy_backend.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/factory/sympy_backend.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Set",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "sympy",
            "as": "sp"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "CompiledEquation",
            "bases": [],
            "doc": "A compiled symbolic equation.\n\n- expr: SymPy expression\n- derivatives: set of SymPy Derivative atoms appearing in expr\n- call: torch-compatible callable from sympy.lambdify\n- args_order: stable argument order for call(...)",
            "class_vars": [
              "args_order",
              "call",
              "derivatives",
              "expr"
            ],
            "methods": []
          },
          {
            "name": "SympyTorchCompiler",
            "bases": [],
            "doc": "Compiles equation strings into torch-callable lambdas using SymPy.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, independent_vars, dependent_vars, inverse_params, extra_namespace)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_create_symbols",
                "signature": "(names)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              },
              {
                "name": "compile",
                "signature": "(self, eq_str)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "SympyBackend",
            "bases": [],
            "doc": "Compatibility wrapper.\n\nYour current PINNFactory uses SympyTorchCompiler directly.\nSome examples may import SympyBackend; this class simply exposes a\nmake_compiler(...) method returning SympyTorchCompiler.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, *, extra_namespace)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "make_compiler",
                "signature": "(self, *, independent_vars, dependent_vars, inverse_params)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_pinn/factory/__init__.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/factory/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "pinn_factory",
            "level": 1,
            "names": [
              {
                "name": "NeuralNetwork",
                "as": null
              },
              {
                "name": "PINN",
                "as": null
              },
              {
                "name": "PINNFactory",
                "as": null
              },
              {
                "name": "PINNProblemSpec",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "sympy_backend",
            "level": 1,
            "names": [
              {
                "name": "SympyTorchCompiler",
                "as": null
              },
              {
                "name": "CompiledEquation",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "autodiff",
            "level": 1,
            "names": [
              {
                "name": "DerivativeComputer",
                "as": null
              },
              {
                "name": "ensure_requires_grad",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_pinn/io/mappings.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/io/mappings.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "xarray",
            "as": "xr"
          }
        ],
        "functions": [
          {
            "name": "seconds_since",
            "signature": "(t, t0)",
            "doc": "Convert datetime64 array to float seconds since t0 (defaults to min(t)).",
            "decorators": []
          },
          {
            "name": "build_default_mapping_atmosphere",
            "signature": "(dep_vars, ind_vars, use_lev, time_transform, angle_transform)",
            "doc": "Default mapping for UPD atmosphere reanalysis shards:\n  coords: time, lat, lon, optionally lev\n  independent vars:\n    - default: [\"t\",\"lat\",\"lon\"] or [\"t\",\"lev\",\"lat\",\"lon\"]\n  transforms:\n    - t: seconds_since_start + minmax to [-1,1]\n    - lat/lon: deg2rad + minmax to [-1,1]",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "CoordMapping",
            "bases": [],
            "doc": "Mapping from UPD coords -> PINN independent variables.\n\nExample:\n  ind_vars = [\"t\",\"x\",\"y\"] mapping:\n    - t <- UPD time (seconds since shard start)\n    - x <- lon (degrees or radians)\n    - y <- lat\n\nnorm:\n  - optional normalization: (x - mean)/std or min-max to [-1,1]\n  - for MVP, we provide simple min-max scaling to [-1,1]",
            "class_vars": [
              "coord_sources",
              "coord_transform",
              "ind_vars",
              "normalize_to_unit"
            ],
            "methods": [
              {
                "name": "_apply_transform",
                "signature": "(self, name, arr, ref)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "make_coord_arrays",
                "signature": "(self, ds, time0)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "VarMapping",
            "bases": [],
            "doc": "Mapping between UPD variable names and PINN dependent variable names.\n\nExample:\n  dep_vars = [\"T\",\"U\",\"V\"]\n  map: {\"T\":\"T2M\", \"U\":\"U10M\", \"V\":\"V10M\"} or direct names.",
            "class_vars": [
              "dep_vars",
              "enforce_present",
              "upd_to_dep"
            ],
            "methods": [
              {
                "name": "pick_dataset_vars",
                "signature": "(self, ds)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "PINNMapping",
            "bases": [],
            "doc": "Full mapping: coordinates -> independent vars, variables -> dependent vars.",
            "class_vars": [
              "coord",
              "var"
            ],
            "methods": [
              {
                "name": "infer_time0",
                "signature": "(self, ds)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "independent_vars",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "dependent_vars",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_pinn/io/upd_dataset.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/io/upd_dataset.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pathlib",
            "level": 0,
            "names": [
              {
                "name": "Path",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "xarray",
            "as": "xr"
          },
          {
            "type": "from",
            "module": "mappings",
            "level": 1,
            "names": [
              {
                "name": "PINNMapping",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "UPDItem",
            "bases": [],
            "doc": "One UPD shard item: points to Zarr and JSON metadata.",
            "class_vars": [
              "meta_path",
              "zarr_path"
            ],
            "methods": [
              {
                "name": "load_meta",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "open_dataset",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "ConditionSpec",
            "bases": [],
            "doc": "Sampling definition for a condition.\n\ntype:\n  - \"initial\": t fixed to first time in shard\n  - \"boundary\": lat/lon boundaries (edges)\n  - \"interior\": random interior points (often used as extra constraints)\n  - \"slice\": any slice on a coord: {\"coord\":\"lev\",\"value\":850}\n\nequation:\n  symbolic equation string (used by PINNFactory separately)\n  stored here only for coordination / debugging.",
            "class_vars": [
              "equation",
              "n",
              "name",
              "options",
              "type"
            ],
            "methods": []
          },
          {
            "name": "SamplingSpec",
            "bases": [],
            "doc": "Overall sampling plan for a UPD shard.",
            "class_vars": [
              "conditions",
              "n_collocation",
              "n_data",
              "replace",
              "seed"
            ],
            "methods": []
          },
          {
            "name": "Batch",
            "bases": [],
            "doc": "A training batch compatible with PINNFactory loss_fn:\n  - collocation: tuple(inputs...) for PDE residual\n  - conditions: list of tuple(inputs...) for each condition\n  - data: (tuple(inputs...), y_true) if provided",
            "class_vars": [
              "collocation",
              "conditions",
              "data"
            ],
            "methods": []
          },
          {
            "name": "UPDDataset",
            "bases": [],
            "doc": "Reads UPD (Zarr + JSON) and produces PINN-ready samples:\n  - collocation points (inputs only)\n  - condition points (inputs only; one list entry per condition)\n  - optional supervised data pairs from UPD variables\n\nNotes:\n  - This MVP samples points directly from the gridded data.\n  - For atmosphere reanalysis, independent vars typically come from coords:\n      time, lat, lon, (optional lev)\n  - Dependent vars (targets) come from UPD variables via mapping.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, item, mapping, device, dtype)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "sample",
                "signature": "(self, spec)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get_problem_dims",
                "signature": "(self)",
                "doc": "Convenience helper: returns independent/dependent vars for creating PINNProblemSpec.",
                "decorators": []
              },
              {
                "name": "_coord_arrays",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_random_index",
                "signature": "(self, rng, size, n, replace)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_mesh_pick",
                "signature": "(self, rng, n, mode, replace, slice_override, boundary_axis)",
                "doc": "Picks random indices for each coord dimension needed by mapping.\nReturns dict {coord_name: idx_array}.",
                "decorators": []
              },
              {
                "name": "_gather_inputs",
                "signature": "(self, idx)",
                "doc": "Given sampled indices for coords, gather independent variables as tensors (N,1).",
                "decorators": []
              },
              {
                "name": "_sample_points",
                "signature": "(self, rng, n, mode, replace)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_sample_condition",
                "signature": "(self, rng, cond)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_sample_data",
                "signature": "(self, rng, n)",
                "doc": "Supervised data: sample points and fetch variable values as y_true.\nFor MVP: y_true is concatenation of dependent vars (N, n_dep).",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_pinn/io/__init__.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/io/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "mappings",
            "level": 1,
            "names": [
              {
                "name": "CoordMapping",
                "as": null
              },
              {
                "name": "VarMapping",
                "as": null
              },
              {
                "name": "PINNMapping",
                "as": null
              },
              {
                "name": "build_default_mapping_atmosphere",
                "as": null
              },
              {
                "name": "seconds_since",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "upd_dataset",
            "level": 1,
            "names": [
              {
                "name": "UPDItem",
                "as": null
              },
              {
                "name": "UPDDataset",
                "as": null
              },
              {
                "name": "Batch",
                "as": null
              },
              {
                "name": "ConditionSpec",
                "as": null
              },
              {
                "name": "SamplingSpec",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_pinn/schemas/schema_adapter.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/schemas/schema_adapter.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinneaple_pinn.factory",
            "level": 0,
            "names": [
              {
                "name": "PINNProblemSpec",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "pinneaple_pinn.io",
            "level": 0,
            "names": [
              {
                "name": "ConditionSpec",
                "as": null
              },
              {
                "name": "SamplingSpec",
                "as": null
              },
              {
                "name": "PINNMapping",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_get",
            "signature": "(d, keys, default)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_as_list",
            "signature": "(x)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_pick_first_present",
            "signature": "(schema, candidates, default)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "SchemaAdapterOptions",
            "bases": [],
            "doc": "Options controlling how a Physical Schema is converted into a PINN problem.\n\nMVP assumptions:\n  - PDE residuals are provided as a list of strings in schema[\"equations\"][\"residuals\"]\n    (or compatible aliases).\n  - Conditions are provided as a list with entries specifying type/name/equation.\n  - For grid UPD, we can auto-map condition types:\n      * \"initial\" -> sample on first time index\n      * \"boundary\" -> sample on lat/lon edges (axis can be specified)\n      * \"slice\" -> sample on coord slice (lev, etc.)",
            "class_vars": [
              "build_sampling_from_conditions",
              "default_condition_weight",
              "default_loss_weights"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "SchemaAdapter",
            "bases": [],
            "doc": "Converts a Physical Schema (UPD/Pinneaple) into:\n  - PINNProblemSpec (for PINNFactory)\n  - Optional: SamplingSpec/ConditionSpec (for UPDDataset)\n\nIntended usage:\n  adapter = SchemaAdapter(mapping, options)\n  problem, sampling = adapter.to_pinn_problem(schema, base_sampling=...)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, mapping, options)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "to_pinn_problem",
                "signature": "(self, schema, *, base_sampling, verbose)",
                "doc": "Returns:\n  (problem_spec, sampling_spec_or_none)\n\nbase_sampling:\n  if provided, we will copy n_collocation/n_data/replace/seed and only\n  append conditions derived from schema (unless already given).",
                "decorators": []
              },
              {
                "name": "_extract_pde_residuals",
                "signature": "(self, schema)",
                "doc": "Tries common locations:\n  schema[\"equations\"][\"residuals\"]\n  schema[\"governing_equations\"][\"residuals\"]\n  schema[\"pde\"][\"residuals\"]\n  schema[\"pde_residuals\"]",
                "decorators": []
              },
              {
                "name": "_extract_inverse_params",
                "signature": "(self, schema)",
                "doc": "Common locations:\n  schema[\"inverse\"][\"params\"]  -> list[str]\n  schema[\"inverse_params\"]     -> list[str]",
                "decorators": []
              },
              {
                "name": "_extract_loss_weights",
                "signature": "(self, schema)",
                "doc": "Common locations:\n  schema[\"loss\"][\"weights\"]\n  schema[\"loss_weights\"]",
                "decorators": []
              },
              {
                "name": "_extract_conditions",
                "signature": "(self, schema)",
                "doc": "Conditions format (MVP):\n  schema[\"conditions\"] = [\n    {\"name\":\"ic_T\", \"type\":\"initial\", \"equation\":\"T - T0\", \"weight\":1.0, \"n\":1024, \"options\":{...}},\n    {\"name\":\"bc_wall\", \"type\":\"boundary\", \"equation\":\"U\", \"axis\":\"lat\", ...},\n  ]\n\nWe output a list of dicts compatible with PINNProblemSpec.conditions:\n  {\"name\":..., \"equation\":..., \"weight\":...}",
                "decorators": []
              },
              {
                "name": "_build_sampling",
                "signature": "(self, schema, *, base_sampling, conditions)",
                "doc": "Creates a SamplingSpec for UPDDataset from schema conditions.\n\nWe interpret condition type fields:\n  - initial: ConditionSpec(type=\"initial\")\n  - boundary: ConditionSpec(type=\"boundary\", options={\"axis\": ...})\n  - slice: ConditionSpec(type=\"slice\", options={\"coord\": ..., \"value\": ...})\n  - interior: ConditionSpec(type=\"interior\")",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_pinn/schemas/__init__.py": {
      "package": "pinneaple_pinn",
      "path": "pinneaple_pinn/schemas/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_problemdesign/agent.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/agent.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "protocol",
            "level": 1,
            "names": [
              {
                "name": "LLMProvider",
                "as": null
              },
              {
                "name": "LLMMessage",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "state",
            "level": 1,
            "names": [
              {
                "name": "DesignState",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 1,
            "names": [
              {
                "name": "Gap",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "extractor",
            "level": 1,
            "names": [
              {
                "name": "extract_from_text",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "merge",
            "level": 1,
            "names": [
              {
                "name": "merge_into_spec",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "policy",
            "level": 1,
            "names": [
              {
                "name": "apply_non_invention_policy",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "elicitation.stages",
            "level": 1,
            "names": [
              {
                "name": "STAGES_ORDER",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "elicitation.questions",
            "level": 1,
            "names": [
              {
                "name": "build_stage_gaps",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "elicitation.validators",
            "level": 1,
            "names": [
              {
                "name": "validate_and_suggest",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "knowledge.mapping",
            "level": 1,
            "names": [
              {
                "name": "build_plan_fno_first",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "renderers.report_md",
            "level": 1,
            "names": [
              {
                "name": "render_markdown_report",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_deep_get",
            "signature": "(d, path)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_stage_required_satisfied",
            "signature": "(spec_dict, required_fields)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_dedup_gaps",
            "signature": "(gaps)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "DesignAgent",
            "bases": [],
            "doc": "High-level flow:\n  - ingest user message\n  - structured extraction (json_mode=True)\n  - safe merge into ProblemSpec\n  - non-invention policy => unknown -> Gap, assumptions -> Assumption\n  - stage-based gap generation\n  - once sufficient => build plan (FNO-first) and render report",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, llm)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "start",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "ingest_user_message",
                "signature": "(self, state, user_text)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "step",
                "signature": "(self, state)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "resolve_gap",
                "signature": "(self, state, gap_id)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_next_stage",
                "signature": "(self, current)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_rewrite_questions",
                "signature": "(self, state, gaps)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_problemdesign/cli.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/cli.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "protocol",
            "level": 1,
            "names": [
              {
                "name": "GeminiProvider",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "agent",
            "level": 1,
            "names": [
              {
                "name": "DesignAgent",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "main",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/extractor.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/extractor.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "import",
            "name": "re",
            "as": null
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "protocol",
            "level": 1,
            "names": [
              {
                "name": "LLMProvider",
                "as": null
              },
              {
                "name": "LLMMessage",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_strip_code_fences",
            "signature": "(text)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_extract_first_json_object",
            "signature": "(text)",
            "doc": "If the model returns extra text, try to extract the first JSON object.",
            "decorators": []
          },
          {
            "name": "extract_from_text",
            "signature": "(llm, user_text)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/merge.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/merge.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 1,
            "names": [
              {
                "name": "ProblemSpec",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_deep_merge",
            "signature": "(dst, src)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "merge_into_spec",
            "signature": "(spec, partial)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/policy.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/policy.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 1,
            "names": [
              {
                "name": "Gap",
                "as": null
              },
              {
                "name": "Assumption",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_dedup_by_id",
            "signature": "(gaps)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "apply_non_invention_policy",
            "signature": "(state, *, unknown_fields, assumptions_suggested, gaps_suggested)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/protocol.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/protocol.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Protocol",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "google.generativeai",
            "as": "genai"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "LLMMessage",
            "bases": [],
            "doc": null,
            "class_vars": [
              "content",
              "role"
            ],
            "methods": []
          },
          {
            "name": "LLMResponse",
            "bases": [],
            "doc": null,
            "class_vars": [
              "raw",
              "text"
            ],
            "methods": []
          },
          {
            "name": "LLMProvider",
            "bases": [
              "Protocol"
            ],
            "doc": "Single interface for the module. Plug Gemini in here.",
            "class_vars": [],
            "methods": [
              {
                "name": "generate",
                "signature": "(self, messages, *, temperature, max_tokens, json_mode)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "GeminiProvider",
            "bases": [],
            "doc": "Real Gemini provider using Google Generative AI SDK.\nRequires environment variable: GOOGLE_API_KEY",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, model)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_convert_messages",
                "signature": "(self, messages)",
                "doc": "Convert internal message format to Gemini format.\nGemini expects:\n[\n    {\"role\": \"user\", \"parts\": [\"text\"]},\n    {\"role\": \"model\", \"parts\": [\"text\"]}\n]",
                "decorators": []
              },
              {
                "name": "generate",
                "signature": "(self, messages, *, temperature, max_tokens, json_mode)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_problemdesign/schema.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/schema.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              },
              {
                "name": "asdict",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "datetime",
            "level": 0,
            "names": [
              {
                "name": "datetime",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Assumption",
            "bases": [],
            "doc": null,
            "class_vars": [
              "confidence",
              "needs_confirmation",
              "text"
            ],
            "methods": []
          },
          {
            "name": "Risk",
            "bases": [],
            "doc": null,
            "class_vars": [
              "level",
              "mitigation",
              "text"
            ],
            "methods": []
          },
          {
            "name": "DataSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "format",
              "known_quality_issues",
              "labels_available",
              "missingness",
              "sampling",
              "sources",
              "target_variables",
              "train_span",
              "val_split_policy",
              "variables_observed"
            ],
            "methods": []
          },
          {
            "name": "PhysicsSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "boundary_conditions",
              "constraints",
              "governing_equations",
              "initial_conditions",
              "parameters_known",
              "parameters_unknown",
              "units"
            ],
            "methods": []
          },
          {
            "name": "GeometrySpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "coordinate_system",
              "domain",
              "representation",
              "sensors"
            ],
            "methods": []
          },
          {
            "name": "ValidationSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "acceptance_criteria",
              "ood_scenarios",
              "primary_metrics",
              "robustness_tests"
            ],
            "methods": []
          },
          {
            "name": "DeploymentSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "environment",
              "latency_budget_ms",
              "monitoring",
              "update_policy"
            ],
            "methods": []
          },
          {
            "name": "ConstraintsSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "compliance",
              "hardware",
              "interpretability",
              "max_training_time"
            ],
            "methods": []
          },
          {
            "name": "ProblemSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "assumptions",
              "constraints",
              "data",
              "deployment",
              "domain_context",
              "frequency",
              "geometry",
              "goal",
              "horizon",
              "input_window",
              "inputs",
              "outputs",
              "physics",
              "risks",
              "task_type",
              "title",
              "validation"
            ],
            "methods": [
              {
                "name": "to_dict",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "Gap",
            "bases": [],
            "doc": null,
            "class_vars": [
              "how_to_obtain",
              "id",
              "question",
              "rationale",
              "resolved",
              "severity"
            ],
            "methods": []
          },
          {
            "name": "PlanStep",
            "bases": [],
            "doc": null,
            "class_vars": [
              "actions",
              "exit_criteria",
              "pinneaple_modules",
              "title",
              "why"
            ],
            "methods": []
          },
          {
            "name": "Plan",
            "bases": [],
            "doc": null,
            "class_vars": [
              "alternatives",
              "go_no_go",
              "recommended_approach",
              "steps"
            ],
            "methods": []
          },
          {
            "name": "DesignReport",
            "bases": [],
            "doc": null,
            "class_vars": [
              "created_at",
              "gaps",
              "plan",
              "spec"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_problemdesign/state.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/state.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 1,
            "names": [
              {
                "name": "ProblemSpec",
                "as": null
              },
              {
                "name": "Gap",
                "as": null
              },
              {
                "name": "Plan",
                "as": null
              },
              {
                "name": "DesignReport",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Turn",
            "bases": [],
            "doc": null,
            "class_vars": [
              "content",
              "role"
            ],
            "methods": []
          },
          {
            "name": "DesignState",
            "bases": [],
            "doc": null,
            "class_vars": [
              "done",
              "gaps",
              "history",
              "plan",
              "spec",
              "stage"
            ],
            "methods": [
              {
                "name": "add_turn",
                "signature": "(self, role, content)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "unresolved_gaps",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "to_report",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_problemdesign/__init__.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "agent",
            "level": 1,
            "names": [
              {
                "name": "DesignAgent",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 1,
            "names": [
              {
                "name": "ProblemSpec",
                "as": null
              },
              {
                "name": "Gap",
                "as": null
              },
              {
                "name": "Plan",
                "as": null
              },
              {
                "name": "PlanStep",
                "as": null
              },
              {
                "name": "DesignReport",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "state",
            "level": 1,
            "names": [
              {
                "name": "DesignState",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "protocol",
            "level": 1,
            "names": [
              {
                "name": "LLMProvider",
                "as": null
              },
              {
                "name": "LLMMessage",
                "as": null
              },
              {
                "name": "LLMResponse",
                "as": null
              },
              {
                "name": "GeminiProvider",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_problemdesign/elicitation/questions.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/elicitation/questions.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 2,
            "names": [
              {
                "name": "Gap",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "build_stage_gaps",
            "signature": "(stage, spec_dict)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/elicitation/stages.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/elicitation/stages.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Literal",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Stage",
            "bases": [],
            "doc": null,
            "class_vars": [
              "description",
              "name",
              "required_fields"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_problemdesign/elicitation/validators.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/elicitation/validators.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 2,
            "names": [
              {
                "name": "ProblemSpec",
                "as": null
              },
              {
                "name": "Assumption",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "validate_and_suggest",
            "signature": "(spec)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/elicitation/__init__.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/elicitation/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "stages",
            "level": 1,
            "names": [
              {
                "name": "STAGES_ORDER",
                "as": null
              },
              {
                "name": "Stage",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "questions",
            "level": 1,
            "names": [
              {
                "name": "build_stage_gaps",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "validators",
            "level": 1,
            "names": [
              {
                "name": "validate_and_suggest",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_problemdesign/knowledge/mapping.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/knowledge/mapping.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 2,
            "names": [
              {
                "name": "ProblemSpec",
                "as": null
              },
              {
                "name": "Plan",
                "as": null
              },
              {
                "name": "PlanStep",
                "as": null
              },
              {
                "name": "Gap",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "build_plan_fno_first",
            "signature": "(spec, gaps)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/knowledge/pinneaple_capabilities.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/knowledge/pinneaple_capabilities.py",
      "parsed": {
        "doc": null,
        "imports": [],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_problemdesign/knowledge/__init__.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/knowledge/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "pinneaple_capabilities",
            "level": 1,
            "names": [
              {
                "name": "PINNEAPLE_CAPABILITIES",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "mapping",
            "level": 1,
            "names": [
              {
                "name": "build_plan_fno_first",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_problemdesign/renderers/report_json.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/renderers/report_json.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "from",
            "module": "schema",
            "level": 2,
            "names": [
              {
                "name": "DesignReport",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "render_json_report",
            "signature": "(report, *, indent)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/renderers/report_md.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/renderers/report_md.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "schema",
            "level": 2,
            "names": [
              {
                "name": "DesignReport",
                "as": null
              },
              {
                "name": "Gap",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_format_gaps",
            "signature": "(gaps)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "render_markdown_report",
            "signature": "(report, warnings)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_problemdesign/renderers/__init__.py": {
      "package": "pinneaple_problemdesign",
      "path": "pinneaple_problemdesign/renderers/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "report_md",
            "level": 1,
            "names": [
              {
                "name": "render_markdown_report",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "report_json",
            "level": 1,
            "names": [
              {
                "name": "render_json_report",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_solvers/base.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "SolverOutput",
            "bases": [],
            "doc": "Standard output for solvers / numerical methods.\nresult:\n  - main output tensor (spectra, modes, field solution, etc.)\nextras:\n  - metadata (freqs, imfs, diagnostics, residuals)",
            "class_vars": [
              "extras",
              "losses",
              "result"
            ],
            "methods": []
          },
          {
            "name": "SolverBase",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "mse",
                "signature": "(a, b)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          }
        ]
      }
    },
    "pinneaple_solvers/fem.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/fem.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SolverBase",
                "as": null
              },
              {
                "name": "SolverOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "FEMSolver",
            "bases": [
              "SolverBase"
            ],
            "doc": "FEM Solver (scaffold MVP).\n\nDesign:\n  - assemble(K, f) from mesh + coefficients (provided by user)\n  - apply BCs\n  - solve linear system K u = f (or nonlinear via iteration later)\n\nThis MVP focuses on API shape & linear solve.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, *, assemble_fn, apply_bcs_fn, solver, tol, max_iter)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_solve",
                "signature": "(self, K, f)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *, mesh, params)",
                "doc": "mesh: pinneaple_geom mesh object (or trimesh/meshio wrapper)\nparams: PDE coefficients, source terms, BC definitions, etc.\n\nassemble_fn(mesh, params) -> (K, f)\napply_bcs_fn(K, f, params) -> (K2, f2) optional",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_solvers/fft.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/fft.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "List",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SolverBase",
                "as": null
              },
              {
                "name": "SolverOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "FFTSolver",
            "bases": [
              "SolverBase"
            ],
            "doc": "FFT Solver (PyTorch backend).\n\nSupports:\n  - rFFT / FFT\n  - 1D/2D/3D along specified dims\n  - returns spectrum (complex split into real/imag) or magnitude/phase\n\nTypical use:\n  - compute spectra of time series or spatial fields\n  - build physics features (energy in bands, dominant freq, etc.)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, *, dims, real_input, output, norm)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x, *, d)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_solvers/fvm.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/fvm.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SolverBase",
                "as": null
              },
              {
                "name": "SolverOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "FVMSolver",
            "bases": [
              "SolverBase"
            ],
            "doc": "FVM Solver (scaffold MVP).\n\nDesign:\n  - build discrete operator from mesh volumes/faces\n  - compute fluxes across faces\n  - time integration (explicit Euler MVP)\n\nUser provides:\n  - flux_fn(state_cell, state_neighbor, face_info, params) -> flux\n  - source_fn(state_cell, cell_info, params) -> source",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, *, flux_fn, source_fn)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, *, mesh, u0, steps, dt, topology, params)",
                "doc": "topology expected keys (typical):\n  - \"faces\": (F,2) cell indices (left,right), right=-1 for boundary\n  - \"areas\": (F,1)\n  - \"normals\": (F,dim)\n  - \"volumes\": (Nc,1)\n  - \"boundary_state\" optional callback or tensor for ghost cells",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_solvers/hilbert_huang.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/hilbert_huang.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SolverBase",
                "as": null
              },
              {
                "name": "SolverOutput",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_find_extrema",
            "signature": "(x)",
            "doc": "x: (T,)\nreturns indices of local maxima and minima (1D)",
            "decorators": []
          },
          {
            "name": "_linear_envelope",
            "signature": "(x, idx)",
            "doc": "Build linear envelope passing through points (idx, x[idx]).\nIncludes endpoints for stability.",
            "decorators": []
          },
          {
            "name": "_is_imf",
            "signature": "(h)",
            "doc": "IMF conditions (loose):\n  - number of extrema and zero crossings differ by <= 1\n  - local mean of envelopes is small-ish (handled in sifting loop)",
            "decorators": []
          },
          {
            "name": "_hilbert_analytic",
            "signature": "(x)",
            "doc": "analytic signal via FFT method.\nx: (T,)\nreturns z: complex (T,)",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "HilbertHuangSolver",
            "bases": [
              "SolverBase"
            ],
            "doc": "HilbertHuang Transform (HHT) MVP for 1D signals.\n\nSteps:\n  1) EMD: decompose x into IMFs + residual\n  2) Hilbert transform each IMF -> inst amplitude & frequency\n\nNotes:\n  - This MVP targets research workflows; for production-grade EMD,\n    you'd typically use a dedicated library.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, *, max_imfs, max_sift, stop_mean_tol, dt)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "emd",
                "signature": "(self, x)",
                "doc": "x: (T,) float\nreturns:\n  imfs: (K,T)\n  residual: (T,)",
                "decorators": [
                  "torch.no_grad()"
                ]
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": "x: (T,) or (B,T)\nOutput:\n  result: imfs (B,K,T) padded to max K across batch\n  extras: residual, inst_amp, inst_freq (same padding)",
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_solvers/registry.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Type",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SolverBase",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "fft",
            "level": 1,
            "names": [
              {
                "name": "FFTSolver",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "hilbert_huang",
            "level": 1,
            "names": [
              {
                "name": "HilbertHuangSolver",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "fem",
            "level": 1,
            "names": [
              {
                "name": "FEMSolver",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "fvm",
            "level": 1,
            "names": [
              {
                "name": "FVMSolver",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "SolverCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "registry"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "get",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_solvers/__init__.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "base",
            "level": 1,
            "names": [
              {
                "name": "SolverBase",
                "as": null
              },
              {
                "name": "SolverOutput",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "SolverCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_solvers/adapters/upd_mesh.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/adapters/upd_mesh.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "_to_torch",
            "signature": "(x, device, dtype)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "_extract_mesh_arrays",
            "signature": "(mesh)",
            "doc": "Duck-typed mesh extraction.\n\nAccepts:\n  - trimesh.Trimesh: mesh.vertices, mesh.faces\n  - meshio.Mesh: mesh.points, mesh.cells_dict (tri/tetra/quad/hex)\n  - Pinneaple mesh wrapper with .vertices/.faces or .points/.cells_dict",
            "decorators": []
          },
          {
            "name": "mesh_to_fvm_topology",
            "signature": "(mesh, *, device, dtype)",
            "doc": "Build a minimal FVM topology from a surface mesh (triangles/quads).\n\nMVP assumptions:\n  - Treat each face as a cell (good for surface PDEs / transport on surfaces).\n  - Build adjacency by shared edges between faces.\n  - Areas per face computed; \"volumes\" is area (surface control-volume).\n\nOutput keys:\n  - faces: (F,2) edge-adjacent face indices (left,right), right=-1 for boundary edge\n  - areas: (E,1) edge area weight (uses edge length as a proxy)\n  - normals: (E,3) edge normals proxy (not exact; placeholder)\n  - volumes: (F,1) face areas",
            "decorators": []
          },
          {
            "name": "mesh_to_fem_assembly_inputs",
            "signature": "(mesh, *, device, dtype)",
            "doc": "Minimal FEM assembly inputs (MVP):\n  - nodes (N,3)\n  - elements (E,k) connectivity\nThe actual K,f assembly is handled by user-provided assemble_fn (in FEMSolver).",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_solvers/adapters/upd_signal.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/adapters/upd_signal.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "_as_tensor",
            "signature": "(x, device, dtype)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "list_field_vars",
            "signature": "(sample)",
            "doc": "Tries to list available physical field variables from a PhysicalSample-like object.\n\nExpected (duck-typed):\n  - sample.fields: Dict[str, Tensor/ndarray]\n    OR\n  - sample.state: Dict[str, Tensor/ndarray]",
            "decorators": []
          },
          {
            "name": "_get_field",
            "signature": "(sample, var)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "list_signal_axes",
            "signature": "(sample, var)",
            "doc": "Best-effort axis naming for a field.\nIf sample has sample.axes[var] or sample.dims[var], use it.\nFallback: [\"dim0\",\"dim1\",...]",
            "decorators": []
          },
          {
            "name": "extract_1d_signal",
            "signature": "(sample, *, var, axis, reduce, index, device, dtype)",
            "doc": "Extract a 1D signal from a (possibly multi-dim) physical field.\n\nOptions:\n  - choose axis (int or axis name if available)\n  - either:\n      * reduce all other axes (mean/sum/median/max/min)\n      * OR pick a fixed index for all other axes via `index` (single int for simplicity)\n\nReturns:\n  signal: (T,)\n  meta: includes chosen axis name, original shape, reduction mode, and dt if sample provides it",
            "decorators": []
          },
          {
            "name": "to_signal_batch",
            "signature": "(samples, *, var, axis, reduce, index, device, dtype)",
            "doc": "Convert a list of samples into a padded batch tensor (B,Tmax).\n\nReturns:\n  xb: (B,Tmax) padded with zeros\n  metas: list of dicts (per sample)",
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_solvers/adapters/__init__.py": {
      "package": "pinneaple_solvers",
      "path": "pinneaple_solvers/adapters/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "upd_signal",
            "level": 1,
            "names": [
              {
                "name": "extract_1d_signal",
                "as": null
              },
              {
                "name": "list_field_vars",
                "as": null
              },
              {
                "name": "list_signal_axes",
                "as": null
              },
              {
                "name": "to_signal_batch",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "upd_mesh",
            "level": 1,
            "names": [
              {
                "name": "mesh_to_fvm_topology",
                "as": null
              },
              {
                "name": "mesh_to_fem_assembly_inputs",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_timeseries/base.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/base.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "TSOutput",
            "bases": [],
            "doc": null,
            "class_vars": [
              "extras",
              "y_hat"
            ],
            "methods": []
          },
          {
            "name": "TSModelBase",
            "bases": [
              "nn.Module"
            ],
            "doc": "Base opcional para modelos TS.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_timeseries/datamodule.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/datamodule.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "torch.utils.data",
            "level": 0,
            "names": [
              {
                "name": "DataLoader",
                "as": null
              },
              {
                "name": "random_split",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "datasets.windowed",
            "level": 1,
            "names": [
              {
                "name": "WindowedTimeSeriesDataset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "spec",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesSpec",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "TSDataModule",
            "bases": [],
            "doc": null,
            "class_vars": [
              "batch_size",
              "series",
              "spec",
              "val_ratio"
            ],
            "methods": [
              {
                "name": "make_loaders",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_timeseries/losses.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/losses.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "import",
            "name": "torch.nn.functional",
            "as": "F"
          }
        ],
        "functions": [
          {
            "name": "mse_forecast",
            "signature": "(model, y_hat, batch)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_timeseries/metrics.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/metrics.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "mae",
            "signature": "(y_hat, batch)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "mse",
            "signature": "(y_hat, batch)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "default_ts_metrics",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_timeseries/registry.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/registry.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "pinneaple_models.registry",
            "level": 0,
            "names": [
              {
                "name": "ModelRegistry",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "models.fno_forecaster",
            "level": 1,
            "names": [
              {
                "name": "FNOForecaster",
                "as": null
              },
              {
                "name": "FNOForecastConfig",
                "as": null
              }
            ]
          }
        ],
        "functions": [
          {
            "name": "_ensure_ts_fno_registered",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "TSModelCatalog",
            "bases": [],
            "doc": null,
            "class_vars": [
              "default_name",
              "families"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "list",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build",
                "signature": "(self, name, **kwargs)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "spec",
                "signature": "(self, name)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "build_default_fno",
                "signature": "(self, *, input_len, horizon, n_features, n_targets, width, modes, layers)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_timeseries/spec.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/spec.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "TimeSeriesSpec",
            "bases": [],
            "doc": null,
            "class_vars": [
              "horizon",
              "input_len",
              "stride",
              "target_offset"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_timeseries/__init__.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "spec",
            "level": 1,
            "names": [
              {
                "name": "TimeSeriesSpec",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "datamodule",
            "level": 1,
            "names": [
              {
                "name": "TSDataModule",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "registry",
            "level": 1,
            "names": [
              {
                "name": "TSModelCatalog",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_timeseries/adapters/shape.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/adapters/shape.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "LastStepToHorizon",
            "bases": [
              "nn.Module"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, model, horizon)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_timeseries/adapters/__init__.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/adapters/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_timeseries/datasets/windowed.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/datasets/windowed.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "torch.utils.data",
            "level": 0,
            "names": [
              {
                "name": "Dataset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "spec",
            "level": 2,
            "names": [
              {
                "name": "TimeSeriesSpec",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "WindowedTimeSeriesDataset",
            "bases": [
              "Dataset"
            ],
            "doc": "series: (T, F)\nx: (L_in, F)\ny: (H, C)   (aqui C = F por padro)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, series, spec)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__len__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__getitem__",
                "signature": "(self, idx)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_timeseries/datasets/__init__.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/datasets/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_timeseries/models/fno_forecaster.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/models/fno_forecaster.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "pinneaple_models.neural_operators.fno",
            "level": 0,
            "names": [
              {
                "name": "FourierNeuralOperator",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "FNOForecastConfig",
            "bases": [],
            "doc": null,
            "class_vars": [
              "horizon",
              "input_len",
              "layers",
              "modes",
              "n_features",
              "n_targets",
              "width"
            ],
            "methods": []
          },
          {
            "name": "FNOForecaster",
            "bases": [
              "nn.Module"
            ],
            "doc": "Forecaster TS padro usando FNO-1D.\nConveno:\n  x: (B, L_in, F)\n  y_hat: (B, H, C)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "forward",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_timeseries/models/__init__.py": {
      "package": "pinneaple_timeseries",
      "path": "pinneaple_timeseries/models/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [],
        "functions": [],
        "classes": []
      }
    },
    "pinneaple_train/audit.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/audit.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "asdict",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "import",
            "name": "json",
            "as": null
          },
          {
            "type": "import",
            "name": "time",
            "as": null
          },
          {
            "type": "import",
            "name": "platform",
            "as": null
          },
          {
            "type": "import",
            "name": "hashlib",
            "as": null
          },
          {
            "type": "import",
            "name": "random",
            "as": null
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "set_seed",
            "signature": "(seed)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "set_deterministic",
            "signature": "(deterministic)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "env_fingerprint",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "RunLogger",
            "bases": [],
            "doc": "JSONL logger for industry-grade auditability.",
            "class_vars": [
              "flush_every",
              "out_dir",
              "run_name"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "log",
                "signature": "(self, record)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "save_config",
                "signature": "(self, cfg)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "save_artifact",
                "signature": "(self, name, obj)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/callbacks.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/callbacks.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "EarlyStopping",
            "bases": [],
            "doc": null,
            "class_vars": [
              "bad_epochs",
              "best",
              "min_delta",
              "mode",
              "monitor",
              "patience",
              "stop"
            ],
            "methods": [
              {
                "name": "update",
                "signature": "(self, logs)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "ModelCheckpoint",
            "bases": [],
            "doc": null,
            "class_vars": [
              "best",
              "mode",
              "monitor",
              "path"
            ],
            "methods": [
              {
                "name": "maybe_save",
                "signature": "(self, model, extra, logs)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/checkpoint.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/checkpoint.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "os",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "save_checkpoint",
            "signature": "(path, ckpt)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "load_checkpoint",
            "signature": "(path)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "Checkpoint",
            "bases": [],
            "doc": null,
            "class_vars": [
              "cfg",
              "meta",
              "model_state",
              "normalizers",
              "optim_state"
            ],
            "methods": []
          }
        ]
      }
    },
    "pinneaple_train/datamodule.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/datamodule.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "from",
            "module": "torch.utils.data",
            "level": 0,
            "names": [
              {
                "name": "Dataset",
                "as": null
              },
              {
                "name": "DataLoader",
                "as": null
              },
              {
                "name": "Subset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "splits",
            "level": 1,
            "names": [
              {
                "name": "SplitSpec",
                "as": null
              },
              {
                "name": "split_indices",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "preprocess",
            "level": 1,
            "names": [
              {
                "name": "PreprocessPipeline",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "ItemAdapter",
            "bases": [],
            "doc": "Adapter that standardizes how we convert dataset items into dict batches.\n\nOutput dict must have at least:\n  - \"x\": Tensor\n  - optional \"y\": Tensor\n  - optional \"meta\": dict\n  - optional \"physics\": dict (for PINN hooks)",
            "class_vars": [],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, item)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "FnAdapter",
            "bases": [
              "ItemAdapter"
            ],
            "doc": "Convenience adapter for Pinneaple PhysicalSample-like objects (or any object).\n\nYou pass:\n  x_fn(sample) -> Tensor\n  y_fn(sample) -> Tensor\n  meta_fn(sample) -> dict (optional)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, x_fn, y_fn, meta_fn)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__call__",
                "signature": "(self, sample)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "AdaptedSequenceDataset",
            "bases": [
              "Dataset"
            ],
            "doc": "Wrap a Python sequence and apply an adapter in __getitem__.\nUseful for: list[PhysicalSample] or list[dict] etc.",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, samples, adapter)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__len__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "__getitem__",
                "signature": "(self, idx)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "DataModule",
            "bases": [],
            "doc": "Builds train/val/test DataLoaders with consistent split + preprocess.\n\nNotes:\n  - Uses split_indices(...) from splits.py (no make_splits required).\n  - split default uses default_factory (Python 3.13 dataclasses).\n  - Caches split subsets after first setup().",
            "class_vars": [
              "_cached",
              "adapter",
              "batch_size",
              "dataset",
              "drop_last",
              "group_ids",
              "num_workers",
              "persistent_workers",
              "pin_memory",
              "preprocess",
              "split"
            ],
            "methods": [
              {
                "name": "_as_dataset",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "setup",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_collate",
                "signature": "(self, batch)",
                "doc": "Collate list[dict] -> dict of tensors (stacked) + lists for non-tensors.",
                "decorators": []
              },
              {
                "name": "train_dataloader",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "val_dataloader",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "test_dataloader",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/inference.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/inference.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [
          {
            "name": "load_checkpoint",
            "signature": "(model, path, map_location)",
            "doc": null,
            "decorators": []
          },
          {
            "name": "predict",
            "signature": "(model, x, device)",
            "doc": null,
            "decorators": [
              "torch.no_grad()"
            ]
          }
        ],
        "classes": []
      }
    },
    "pinneaple_train/losses.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/losses.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "field",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          }
        ],
        "functions": [
          {
            "name": "_unwrap_pred",
            "signature": "(y_hat)",
            "doc": "Accepts either:\n  - torch.Tensor\n  - objects with common prediction attributes: y, pred, out, recon, x_hat\nReturns a torch.Tensor prediction.",
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "SupervisedLoss",
            "bases": [],
            "doc": null,
            "class_vars": [
              "kind"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "PhysicsLossHook",
            "bases": [],
            "doc": null,
            "class_vars": [
              "physics_loss_fn"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, model, y_hat, batch)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "CombinedLoss",
            "bases": [],
            "doc": null,
            "class_vars": [
              "physics",
              "supervised",
              "w_physics",
              "w_supervised"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, model, y_hat, batch)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/metrics.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/metrics.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [
          {
            "name": "default_metrics",
            "signature": "()",
            "doc": null,
            "decorators": []
          },
          {
            "name": "regression_metrics_bundle",
            "signature": "()",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "Metric",
            "bases": [],
            "doc": null,
            "class_vars": [
              "name"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "MSE",
            "bases": [
              "Metric"
            ],
            "doc": null,
            "class_vars": [
              "name"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "MAE",
            "bases": [
              "Metric"
            ],
            "doc": null,
            "class_vars": [
              "name"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "RMSE",
            "bases": [
              "Metric"
            ],
            "doc": null,
            "class_vars": [
              "name"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "R2",
            "bases": [
              "Metric"
            ],
            "doc": null,
            "class_vars": [
              "eps",
              "name"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "RelL2",
            "bases": [
              "Metric"
            ],
            "doc": null,
            "class_vars": [
              "eps",
              "name"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "MaxError",
            "bases": [
              "Metric"
            ],
            "doc": null,
            "class_vars": [
              "name"
            ],
            "methods": [
              {
                "name": "__call__",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "Metrics",
            "bases": [],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "compute",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "MetricBundle",
            "bases": [
              "Metrics"
            ],
            "doc": null,
            "class_vars": [
              "metrics"
            ],
            "methods": [
              {
                "name": "compute",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "RegressionMetrics",
            "bases": [
              "Metrics"
            ],
            "doc": null,
            "class_vars": [
              "eps"
            ],
            "methods": [
              {
                "name": "compute",
                "signature": "(self, y_hat, y)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/normalizers.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/normalizers.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Any",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "Normalizer",
            "bases": [],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "fit",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "transform",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "inverse",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "state_dict",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "load_state_dict",
                "signature": "(self, sd)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "StandardScaler",
            "bases": [
              "Normalizer"
            ],
            "doc": null,
            "class_vars": [
              "eps",
              "mean_",
              "std_"
            ],
            "methods": [
              {
                "name": "fit",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "transform",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "inverse",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "state_dict",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "load_state_dict",
                "signature": "(self, sd)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "MinMaxScaler",
            "bases": [
              "Normalizer"
            ],
            "doc": null,
            "class_vars": [
              "eps",
              "max_",
              "min_"
            ],
            "methods": [
              {
                "name": "fit",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "transform",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "inverse",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "state_dict",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "load_state_dict",
                "signature": "(self, sd)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/preprocess.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/preprocess.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Protocol",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Tuple",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "PreprocessStep",
            "bases": [
              "Protocol"
            ],
            "doc": null,
            "class_vars": [],
            "methods": [
              {
                "name": "fit",
                "signature": "(self, batch_list)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "apply",
                "signature": "(self, batch)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "PreprocessPipeline",
            "bases": [],
            "doc": null,
            "class_vars": [
              "steps"
            ],
            "methods": [
              {
                "name": "fit",
                "signature": "(self, train_batches)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "apply",
                "signature": "(self, batch)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "StandardScaler",
            "bases": [],
            "doc": null,
            "class_vars": [
              "eps",
              "mean",
              "std"
            ],
            "methods": [
              {
                "name": "encode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "decode",
                "signature": "(self, x)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(x, dim)",
                "doc": null,
                "decorators": [
                  "staticmethod"
                ]
              }
            ]
          },
          {
            "name": "NormalizeStep",
            "bases": [],
            "doc": "Fits a StandardScaler on `key` from train batches, then normalizes in apply().\nWorks for typical (B,T,D) or (B,D) tensors.",
            "class_vars": [
              "dim",
              "enabled",
              "key",
              "scaler",
              "store_key"
            ],
            "methods": [
              {
                "name": "fit",
                "signature": "(self, batch_list)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "apply",
                "signature": "(self, batch)",
                "doc": null,
                "decorators": []
              }
            ]
          },
          {
            "name": "SolverFeatureStep",
            "bases": [],
            "doc": null,
            "class_vars": [
              "fit_noop",
              "mode",
              "reduce_fft_to",
              "select_var_dim",
              "solver"
            ],
            "methods": [
              {
                "name": "fit",
                "signature": "(self, batch_list)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "apply",
                "signature": "(self, batch)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/splits.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/splits.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "Sequence",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "numpy",
            "as": "np"
          }
        ],
        "functions": [
          {
            "name": "_counts",
            "signature": "(n, train, val)",
            "doc": "Stable split counts:\n  - floor train and val\n  - remainder goes to test\nGuarantees: n_train + n_val + n_test == n",
            "decorators": []
          },
          {
            "name": "split_indices",
            "signature": "(n, spec, *, group_ids)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": [
          {
            "name": "SplitSpec",
            "bases": [],
            "doc": "Split strategies:\n  - random: shuffle then split by ratios\n  - time: keep order; split by ratios (train earliest, test latest)\n  - group: ensure groups don't leak (requires group_ids)",
            "class_vars": [
              "method",
              "seed",
              "test",
              "train",
              "val"
            ],
            "methods": [
              {
                "name": "__post_init__",
                "signature": "(self)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/trainer.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/trainer.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "dataclasses",
            "level": 0,
            "names": [
              {
                "name": "dataclass",
                "as": null
              },
              {
                "name": "asdict",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Any",
                "as": null
              },
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Callable",
                "as": null
              },
              {
                "name": "Union",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "time",
            "as": null
          },
          {
            "type": "import",
            "name": "torch",
            "as": null
          },
          {
            "type": "import",
            "name": "torch.nn",
            "as": "nn"
          },
          {
            "type": "from",
            "module": "preprocess",
            "level": 1,
            "names": [
              {
                "name": "PreprocessPipeline",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "callbacks",
            "level": 1,
            "names": [
              {
                "name": "EarlyStopping",
                "as": null
              },
              {
                "name": "ModelCheckpoint",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "audit",
            "level": 1,
            "names": [
              {
                "name": "set_seed",
                "as": null
              },
              {
                "name": "set_deterministic",
                "as": null
              },
              {
                "name": "RunLogger",
                "as": null
              },
              {
                "name": "env_fingerprint",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "checkpoint",
            "level": 1,
            "names": [
              {
                "name": "Checkpoint",
                "as": null
              },
              {
                "name": "save_checkpoint",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "metrics",
            "level": 1,
            "names": [
              {
                "name": "Metrics",
                "as": null
              },
              {
                "name": "Metric",
                "as": null
              },
              {
                "name": "default_metrics",
                "as": null
              },
              {
                "name": "MetricBundle",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": [
          {
            "name": "TrainConfig",
            "bases": [],
            "doc": null,
            "class_vars": [
              "amp",
              "deterministic",
              "device",
              "epochs",
              "grad_clip",
              "log_dir",
              "lr",
              "run_name",
              "save_best",
              "seed",
              "weight_decay"
            ],
            "methods": []
          },
          {
            "name": "Trainer",
            "bases": [],
            "doc": "Unified trainer:\n  - supports physics-aware losses via loss_fn(model, y_hat, batch)->dict\n  - supports preprocess pipeline\n  - supports callbacks (early stopping / checkpoint)\n  - supports auditable logging + deterministic runs + best checkpoint\n\nBatches:\n  - dict with \"x\" and optional \"y\"\n  - or tuple (x, y)",
            "class_vars": [],
            "methods": [
              {
                "name": "__init__",
                "signature": "(self, model, loss_fn, metrics, preprocess, early_stopping, checkpoint)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_xy_batch",
                "signature": "(self, batch)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_move",
                "signature": "(self, obj, device)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_move_batch",
                "signature": "(self, batch, device)",
                "doc": null,
                "decorators": []
              },
              {
                "name": "_unwrap_pred",
                "signature": "(self, y_hat, batch)",
                "doc": "Convert ModelOutput / AEOutput / etc -> torch.Tensor (prediction).\n\nRule of thumb:\n  - if model returns AEOutput and batch has y:\n      - if y matches z shape -> use z\n      - elif y matches x_hat shape -> use x_hat\n      - else -> default x_hat\n  - otherwise try common attributes: y, pred, x_hat, recon, logits",
                "decorators": []
              },
              {
                "name": "fit",
                "signature": "(self, train_loader, val_loader, cfg)",
                "doc": null,
                "decorators": []
              }
            ]
          }
        ]
      }
    },
    "pinneaple_train/viz.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/viz.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "__future__",
            "level": 0,
            "names": [
              {
                "name": "annotations",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "typing",
            "level": 0,
            "names": [
              {
                "name": "Dict",
                "as": null
              },
              {
                "name": "List",
                "as": null
              },
              {
                "name": "Optional",
                "as": null
              }
            ]
          },
          {
            "type": "import",
            "name": "matplotlib.pyplot",
            "as": "plt"
          }
        ],
        "functions": [
          {
            "name": "plot_history",
            "signature": "(history, keys)",
            "doc": null,
            "decorators": []
          }
        ],
        "classes": []
      }
    },
    "pinneaple_train/__init__.py": {
      "package": "pinneaple_train",
      "path": "pinneaple_train/__init__.py",
      "parsed": {
        "doc": null,
        "imports": [
          {
            "type": "from",
            "module": "splits",
            "level": 1,
            "names": [
              {
                "name": "SplitSpec",
                "as": null
              },
              {
                "name": "split_indices",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "normalizers",
            "level": 1,
            "names": [
              {
                "name": "Normalizer",
                "as": null
              },
              {
                "name": "StandardScaler",
                "as": null
              },
              {
                "name": "MinMaxScaler",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "preprocess",
            "level": 1,
            "names": [
              {
                "name": "PreprocessPipeline",
                "as": null
              },
              {
                "name": "SolverFeatureStep",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "metrics",
            "level": 1,
            "names": [
              {
                "name": "Metrics",
                "as": null
              },
              {
                "name": "RegressionMetrics",
                "as": null
              },
              {
                "name": "default_metrics",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "losses",
            "level": 1,
            "names": [
              {
                "name": "CombinedLoss",
                "as": null
              },
              {
                "name": "SupervisedLoss",
                "as": null
              },
              {
                "name": "PhysicsLossHook",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "callbacks",
            "level": 1,
            "names": [
              {
                "name": "EarlyStopping",
                "as": null
              },
              {
                "name": "ModelCheckpoint",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "trainer",
            "level": 1,
            "names": [
              {
                "name": "Trainer",
                "as": null
              },
              {
                "name": "TrainConfig",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "datamodule",
            "level": 1,
            "names": [
              {
                "name": "DataModule",
                "as": null
              },
              {
                "name": "ItemAdapter",
                "as": null
              },
              {
                "name": "FnAdapter",
                "as": null
              },
              {
                "name": "AdaptedSequenceDataset",
                "as": null
              }
            ]
          },
          {
            "type": "from",
            "module": "audit",
            "level": 1,
            "names": [
              {
                "name": "RunLogger",
                "as": null
              },
              {
                "name": "set_seed",
                "as": null
              },
              {
                "name": "set_deterministic",
                "as": null
              }
            ]
          }
        ],
        "functions": [],
        "classes": []
      }
    }
  },
  "examples_root": "C:\\Users\\laisc\\OneDrive\\Documents\\pinneaple\\examples"
}